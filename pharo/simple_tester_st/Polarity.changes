----QUIT----2024-03-01T12:34:42.799915+01:00 Pharo10-SNAPSHOT-64bit-28169ae.image priorSource: 0!----QUIT----2024-03-01T12:35:12.44966+01:00 Pharo10-SNAPSHOT-64bit-28169ae.image priorSource: 0!'From Pharo11.0.0 of 21 January 2025 [Build information: Pharo-11.0.0+build.735.sha.d63208e5b57d74646d2058654a849c87face150c (64 Bit)] on 29 January 2025 at 4:52:14.968 pm'!Object subclass: #Polarity	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Polarity class	instanceVariableNames: ''!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 16:49'!solveWith: specs and: board	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !----End fileIn----!'From Pharo11.0.0 of 21 January 2025 [Build information: Pharo-11.0.0+build.735.sha.d63208e5b57d74646d2058654a849c87face150c (64 Bit)] on 29 January 2025 at 4:52:08.242 pm'!TestCase subclass: #PolarityTest	instanceVariableNames: 'log'	classVariableNames: ''	package: 'CPS506'!!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:27'!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:30'!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:32'!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl.		^log get_5! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl.		^log get_3b! !!PolarityTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 13:43'!validateSol: sol withSpecs: specs	| left right top bottom rows cols |		rows := sol size.	cols := (sol at: 1) size.		left := specs at: 'left'.	right := specs at: 'right'.	top := specs at: 'top'.	bottom := specs at: 'bottom'.	1 to: rows do: [ :r |		| npos nneg |				npos := (sol at: r) occurrencesOf: $+.		npos = (left at: r) ifFalse: [  			((left at: r) = -1) ifFalse: [ ^'Row ', r asString, ' has wrong number of +' ]		].						nneg := (sol at: r) occurrencesOf: $-.		nneg = (right at: r) ifFalse: [  			((right at: r) = -1) ifFalse: [ ^'Row ', r asString, ' has wrong number of -' ]		].	].	1 to: cols do: [ :c |		| npos nneg |		npos := 0.				nneg := 0.				1 to: rows do: [ :r |			| pole |			pole := (sol at: r) at: c.			pole = $+ ifTrue: [ npos := npos + 1 ].			pole = $- ifTrue: [ nneg := nneg + 1 ].				].			npos = (top at: c) ifFalse: [  			((top at: c) = -1) ifFalse: [ ^'Column ', c asString, ' has wrong number of +' ]		].		nneg = (bottom at: c) ifFalse: [  			((bottom at: c) = -1) ifFalse: [ ^'Column ', c asString, ' has wrong number of -' ]		].	].	^'Constraints met!!'! !!PolarityTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 13:43'!validateSol: sol withBoard: board	| rows cols |		rows := board size.	cols := (board at: 1) size.		" Test solution type, should be Array of Bytestrings "	sol class = Array ifFalse: [ ^'Solution should be returned as Array of ByteString' ].	(sol at: 1) class = ByteString ifFalse: [ ^'Solution should be returned as Array of ByteString' ].		" Test solution size, should match board "	sol size = rows ifFalse: [^'Solution and board have different sizes'].	(sol at: 1) size = cols ifFalse: [^'Solution and board have different sizes'].	" Check characters in solution, can only contain +, -, X "	sol do: [ :r | (r reject: [ :c | #( $+ $- $X ) includes: c ]) = '' ifFalse: [ ^'Solution contains illegal characters' ] ].		" Check rows for adjacent same polarity "	sol do: [ :r | 		1 to: cols - 1 do: [ :i | 			| p1 p2 |			p1 := r at: i.			p2 := r at: i+1.			(p1 = p2) & (p1 ~= $X) ifTrue: [ ^'Solution contains equal adjacent poles (++ or --)' ].		]		].	" Check columns for adjacent same polarity "	1 to: rows-1 do: [ :r |		1 to: cols do: [ :c |			| p1 p2 |			p1 := (sol at: r) at: c.			p2 := (sol at: r+1) at: c.			(p1 = p2) & (p1 ~= $X) ifTrue: [ ^'Solution contains equal adjacent poles (++ or --)' ].		]	].		" Check magnet orientation, no monopoles "	1 to: rows do: [ :r |		1 to: cols do: [ :c |			| b1 s1 s2 bar |			b1 := (board at: r) at: c.			s1 := (sol at: r) at: c.						b1 = $L ifTrue: [ s2 := (sol at: r) at: c+1 ].			b1 = $R ifTrue: [ s2 := (sol at: r) at: c-1 ].			b1 = $T ifTrue: [ s2 := (sol at: r+1) at: c ].			b1 = $B ifTrue: [ s2 := (sol at: r-1) at: c ].						bar := String with: s1 with: s2.			(#( 'XX' '+-' '-+' ) includes: bar) 			ifFalse: [ ^'Solution contains illegal tile placement!!!!!!!! Must be one of +-, -+, XX' ]					]	].		^'Board is valid!!'! !!PolarityTest methodsFor: 'initialization' stamp: 'AU 1/29/2025 16:16'!setLog: lg	log := lg! !----End fileIn----!'From Pharo11.0.0 of 21 January 2025 [Build information: Pharo-11.0.0+build.735.sha.d63208e5b57d74646d2058654a849c87face150c (64 Bit)] on 29 January 2025 at 4:52:11.703 pm'!Object subclass: #PolarityLog	instanceVariableNames: 'res_1 res_2a res_2b res_3a res_3b res_4a res_4b res_5'	classVariableNames: ''	package: 'CPS506'!!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 16:04'!getAll	| nl |	nl := String with: Character cr.	^ self get_1, nl, self get_2a, nl, self get_2b, nl, self get_3a, nl, self get_3b, nl, 		self get_4a, nl, self get_4b, nl, self get_5! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:38'!get_1	^res_1! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_3b	^res_3b! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_5	^res_5! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_3a	^res_3a! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_3b: result	res_3b := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_4b: result	res_4b := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_5: result	res_5 := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_4a	^res_4a! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_2b: result	res_2b := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_3a: result	res_3a := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:41'!set_1: result	res_1 := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_2a	^res_2a! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_2b	^res_2b! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_4a: result	res_4a := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_4b	^res_4b! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_2a: result	res_2a := result! !----End fileIn----!----SNAPSHOT----2025-01-31T07:57:22.632-05:00 Polarity.image priorSource: 99!----SNAPSHOT----2025-01-31T07:59:08.185-05:00 Polarity.image priorSource: 15503!----SNAPSHOT----2025-01-31T08:00:01.879-05:00 Polarity.image priorSource: 15582!----QUIT----2025-01-31T08:00:17.577-05:00 Polarity.image priorSource: 15664!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 2/4/2025 14:21' prior: 33555086!solveWith: board and: specs	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !----SNAPSHOT----2025-02-04T14:21:25.54-05:00 Polarity.image priorSource: 15746!----QUIT/NOSAVE----2025-02-04T14:21:28.19-05:00 Polarity.image priorSource: 16239!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 2/4/2025 14:28' prior: 33570351!solveWith: specs and: board	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33560027!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33561070!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33557918!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33555774!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33563486!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:29' prior: 33556793!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:29' prior: 33558897!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:29' prior: 33562054!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl.		^log get_5! !----SNAPSHOT----2025-02-04T14:29:17.37-05:00 Polarity.image priorSource: 16239!----SNAPSHOT----2025-02-04T14:29:35.648-05:00 Polarity.image priorSource: 25673!----QUIT/NOSAVE----2025-02-04T14:29:38.168-05:00 Polarity.image priorSource: 25754!----QUIT/NOSAVE----2025-02-05T09:04:49.471-05:00 Polarity.image priorSource: 25754!----QUIT/NOSAVE----2025-02-05T10:10:23.826-05:00 Polarity.image priorSource: 25754!----QUIT/NOSAVE----2025-02-12T11:53:46.293-05:00 Polarity.image priorSource: 25754!----QUIT/NOSAVE----2025-02-19T08:15:47.68-05:00 Polarity.image priorSource: 25754!!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:04' prior: 33571330!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33572388!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33573387!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33574381!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33575415!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33576452!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33577592!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33578737!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_5! !----SNAPSHOT----2025-02-19T09:06:40.267-05:00 Polarity.image priorSource: 25754!----QUIT----2025-02-19T09:09:39.937-05:00 Polarity.image priorSource: 35266!----QUIT/NOSAVE----2025-02-25T07:55:19.487-05:00 Polarity.image priorSource: 35348!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 5/7/2025 07:35'!solve: specs with: board	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33582867!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33580772!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33587148!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33583880!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33584933!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33588312!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_5! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33585989!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33581849!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !Polarity class removeSelector: #solveWith:and:!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 5/7/2025 07:35' prior: 33590022!solve: board with: specs	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33591427!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33598378!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33600926!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33590418!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33593660!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33594709!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33597223!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33592500!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33595761!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_5! !----QUIT----2025-05-07T07:37:19.075-04:00 Polarity.image priorSource: 35348!----QUIT/NOSAVE----2025-05-08T13:10:39.521-04:00 Polarity.image priorSource: 55330!----SNAPSHOT----2025-05-08T13:10:52.624-04:00 Polarity.image priorSource: 55330!----QUIT----2025-05-08T13:10:58.631-04:00 Polarity.image priorSource: 55493!----QUIT/NOSAVE----2025-08-15T14:39:24.626-04:00 Polarity.image priorSource: 55575!!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 8/15/2025 14:42' prior: 33599457!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	 ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 8/15/2025 14:43'!canPlace: result on: board row:i column: j type: type|pos notType |    type == $+   ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: (notType)) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: (notType))ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: (notType))ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: (notType))ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 8/15/2025 14:43'!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == $+   ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 8/15/2025 14:43'!updateSpecs: mspecs at: i and: j given: pos andType: typetype == $+ ifTrue:[		pos == $L ifTrue: [				mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j+1 put: ((mspecs at: #bottom at: j+1)-1).		^mspecs	].	pos == $R ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j-1 put: ((mspecs at: #bottom at: j-1)-1).		^mspecs	].	pos == $T ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i+1 put: ((mspecs at: #right at: i+1)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $B ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i-1 put: ((mspecs at: #right at: i-1)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].].type == $- ifTrue: [		pos == $L ifTrue: [				mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j+1 put: ((mspecs at: #top at: j+1)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $R ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j-1 put: ((mspecs at: #top at: j-1)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $T ifTrue: [ 		mspecs at: #left at: i+1 put: ((mspecs at: #left at: i+1)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs  at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $B ifTrue: [ 		mspecs at: #left at: i-1 put: ((mspecs at: #left at: i-1)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].].^mspecs! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 8/15/2025 14:43'!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].(i-1) >= topb ifTrue: [((result at: i-1) at: j)== type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [((result at: i+1)at: j) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 8/15/2025 14:44'!withinbounds: mspecs at: i and: j with: type and: pos|notType|type == $+   ifTrue: [ notType := $- ].type == $- ifTrue: [ notType := $+ ].pos == $L ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i) ~= 0) & ((mspecs at: #top at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i) ~= 0) & ((mspecs at: #bottom at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $R ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i) ~= 0) & ((mspecs at: #top at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i) ~= 0) & ((mspecs at: #bottom at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $T ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i+1) ~= 0) & ((mspecs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i+1) ~= 0) & ((mspecs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $B ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i-1) ~= 0) & ((mspecs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i-1) ~= 0) & ((mspecs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].^false.! !----QUIT----2025-08-15T14:45:25.626-04:00 Polarity.image priorSource: 55575!----QUIT----2025-08-15T14:47:59.959-04:00 Polarity.image priorSource: 65147!