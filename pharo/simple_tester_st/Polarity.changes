----QUIT----2024-03-01T12:34:42.799915+01:00 Pharo10-SNAPSHOT-64bit-28169ae.image priorSource: 0!----QUIT----2024-03-01T12:35:12.44966+01:00 Pharo10-SNAPSHOT-64bit-28169ae.image priorSource: 0!'From Pharo11.0.0 of 21 January 2025 [Build information: Pharo-11.0.0+build.735.sha.d63208e5b57d74646d2058654a849c87face150c (64 Bit)] on 29 January 2025 at 4:52:14.968 pm'!Object subclass: #Polarity	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Polarity class	instanceVariableNames: ''!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 16:49'!solveWith: specs and: board	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !----End fileIn----!'From Pharo11.0.0 of 21 January 2025 [Build information: Pharo-11.0.0+build.735.sha.d63208e5b57d74646d2058654a849c87face150c (64 Bit)] on 29 January 2025 at 4:52:08.242 pm'!TestCase subclass: #PolarityTest	instanceVariableNames: 'log'	classVariableNames: ''	package: 'CPS506'!!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:27'!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:30'!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:32'!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl.		^log get_5! !!PolarityTest methodsFor: 'tests' stamp: 'AU 1/29/2025 16:31'!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: board and: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl.		^log get_3b! !!PolarityTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 13:43'!validateSol: sol withSpecs: specs	| left right top bottom rows cols |		rows := sol size.	cols := (sol at: 1) size.		left := specs at: 'left'.	right := specs at: 'right'.	top := specs at: 'top'.	bottom := specs at: 'bottom'.	1 to: rows do: [ :r |		| npos nneg |				npos := (sol at: r) occurrencesOf: $+.		npos = (left at: r) ifFalse: [  			((left at: r) = -1) ifFalse: [ ^'Row ', r asString, ' has wrong number of +' ]		].						nneg := (sol at: r) occurrencesOf: $-.		nneg = (right at: r) ifFalse: [  			((right at: r) = -1) ifFalse: [ ^'Row ', r asString, ' has wrong number of -' ]		].	].	1 to: cols do: [ :c |		| npos nneg |		npos := 0.				nneg := 0.				1 to: rows do: [ :r |			| pole |			pole := (sol at: r) at: c.			pole = $+ ifTrue: [ npos := npos + 1 ].			pole = $- ifTrue: [ nneg := nneg + 1 ].				].			npos = (top at: c) ifFalse: [  			((top at: c) = -1) ifFalse: [ ^'Column ', c asString, ' has wrong number of +' ]		].		nneg = (bottom at: c) ifFalse: [  			((bottom at: c) = -1) ifFalse: [ ^'Column ', c asString, ' has wrong number of -' ]		].	].	^'Constraints met!!'! !!PolarityTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 13:43'!validateSol: sol withBoard: board	| rows cols |		rows := board size.	cols := (board at: 1) size.		" Test solution type, should be Array of Bytestrings "	sol class = Array ifFalse: [ ^'Solution should be returned as Array of ByteString' ].	(sol at: 1) class = ByteString ifFalse: [ ^'Solution should be returned as Array of ByteString' ].		" Test solution size, should match board "	sol size = rows ifFalse: [^'Solution and board have different sizes'].	(sol at: 1) size = cols ifFalse: [^'Solution and board have different sizes'].	" Check characters in solution, can only contain +, -, X "	sol do: [ :r | (r reject: [ :c | #( $+ $- $X ) includes: c ]) = '' ifFalse: [ ^'Solution contains illegal characters' ] ].		" Check rows for adjacent same polarity "	sol do: [ :r | 		1 to: cols - 1 do: [ :i | 			| p1 p2 |			p1 := r at: i.			p2 := r at: i+1.			(p1 = p2) & (p1 ~= $X) ifTrue: [ ^'Solution contains equal adjacent poles (++ or --)' ].		]		].	" Check columns for adjacent same polarity "	1 to: rows-1 do: [ :r |		1 to: cols do: [ :c |			| p1 p2 |			p1 := (sol at: r) at: c.			p2 := (sol at: r+1) at: c.			(p1 = p2) & (p1 ~= $X) ifTrue: [ ^'Solution contains equal adjacent poles (++ or --)' ].		]	].		" Check magnet orientation, no monopoles "	1 to: rows do: [ :r |		1 to: cols do: [ :c |			| b1 s1 s2 bar |			b1 := (board at: r) at: c.			s1 := (sol at: r) at: c.						b1 = $L ifTrue: [ s2 := (sol at: r) at: c+1 ].			b1 = $R ifTrue: [ s2 := (sol at: r) at: c-1 ].			b1 = $T ifTrue: [ s2 := (sol at: r+1) at: c ].			b1 = $B ifTrue: [ s2 := (sol at: r-1) at: c ].						bar := String with: s1 with: s2.			(#( 'XX' '+-' '-+' ) includes: bar) 			ifFalse: [ ^'Solution contains illegal tile placement!!!!!!!! Must be one of +-, -+, XX' ]					]	].		^'Board is valid!!'! !!PolarityTest methodsFor: 'initialization' stamp: 'AU 1/29/2025 16:16'!setLog: lg	log := lg! !----End fileIn----!'From Pharo11.0.0 of 21 January 2025 [Build information: Pharo-11.0.0+build.735.sha.d63208e5b57d74646d2058654a849c87face150c (64 Bit)] on 29 January 2025 at 4:52:11.703 pm'!Object subclass: #PolarityLog	instanceVariableNames: 'res_1 res_2a res_2b res_3a res_3b res_4a res_4b res_5'	classVariableNames: ''	package: 'CPS506'!!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 16:04'!getAll	| nl |	nl := String with: Character cr.	^ self get_1, nl, self get_2a, nl, self get_2b, nl, self get_3a, nl, self get_3b, nl, 		self get_4a, nl, self get_4b, nl, self get_5! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:38'!get_1	^res_1! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_3b	^res_3b! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_5	^res_5! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_3a	^res_3a! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_3b: result	res_3b := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_4b: result	res_4b := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_5: result	res_5 := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_4a	^res_4a! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_2b: result	res_2b := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_3a: result	res_3a := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:41'!set_1: result	res_1 := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_2a	^res_2a! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_2b	^res_2b! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_4a: result	res_4a := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_4b	^res_4b! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_2a: result	res_2a := result! !----End fileIn----!----SNAPSHOT----2025-01-31T07:57:22.632-05:00 Polarity.image priorSource: 99!----SNAPSHOT----2025-01-31T07:59:08.185-05:00 Polarity.image priorSource: 15503!----SNAPSHOT----2025-01-31T08:00:01.879-05:00 Polarity.image priorSource: 15582!----QUIT----2025-01-31T08:00:17.577-05:00 Polarity.image priorSource: 15664!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 2/4/2025 14:21' prior: 33555086!solveWith: board and: specs	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !----SNAPSHOT----2025-02-04T14:21:25.54-05:00 Polarity.image priorSource: 15746!----QUIT/NOSAVE----2025-02-04T14:21:28.19-05:00 Polarity.image priorSource: 16239!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 2/4/2025 14:28' prior: 33570351!solveWith: specs and: board	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33560027!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33561070!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33557918!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33555774!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:28' prior: 33563486!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:29' prior: 33556793!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:29' prior: 33558897!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/4/2025 14:29' prior: 33562054!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl.		^log get_5! !----SNAPSHOT----2025-02-04T14:29:17.37-05:00 Polarity.image priorSource: 16239!----SNAPSHOT----2025-02-04T14:29:35.648-05:00 Polarity.image priorSource: 25673!----QUIT/NOSAVE----2025-02-04T14:29:38.168-05:00 Polarity.image priorSource: 25754!----QUIT/NOSAVE----2025-02-05T09:04:49.471-05:00 Polarity.image priorSource: 25754!----QUIT/NOSAVE----2025-02-05T10:10:23.826-05:00 Polarity.image priorSource: 25754!----QUIT/NOSAVE----2025-02-12T11:53:46.293-05:00 Polarity.image priorSource: 25754!----QUIT/NOSAVE----2025-02-19T08:15:47.68-05:00 Polarity.image priorSource: 25754!!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:04' prior: 33571330!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33572388!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33573387!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33574381!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33575415!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33576452!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33577592!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05' prior: 33578737!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_5! !----SNAPSHOT----2025-02-19T09:06:40.267-05:00 Polarity.image priorSource: 25754!----QUIT----2025-02-19T09:09:39.937-05:00 Polarity.image priorSource: 35266!----QUIT/NOSAVE----2025-02-25T07:55:19.487-05:00 Polarity.image priorSource: 35348!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 5/7/2025 07:35'!solve: specs with: board	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33582867!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33580772!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33587148!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33583880!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33584933!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33588312!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_5! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33585989!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:35' prior: 33581849!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solve: specs with: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !Polarity class removeSelector: #solveWith:and:!!Polarity class methodsFor: 'as yet unclassified' stamp: 'AU 5/7/2025 07:35' prior: 33590022!solve: board with: specs	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33591427!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33598378!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33600926!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33590418!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33593660!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33594709!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33597223!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33592500!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 5/7/2025 07:36' prior: 33595761!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solve: board with: specs.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_5! !----QUIT----2025-05-07T07:37:19.075-04:00 Polarity.image priorSource: 35348!----QUIT/NOSAVE----2025-05-08T13:10:39.521-04:00 Polarity.image priorSource: 55330!----SNAPSHOT----2025-05-08T13:10:52.624-04:00 Polarity.image priorSource: 55330!----QUIT----2025-05-08T13:10:58.631-04:00 Polarity.image priorSource: 55493!----QUIT/NOSAVE----2025-06-07T02:29:21.557-04:00 Polarity.image priorSource: 55575!----QUIT/NOSAVE----2025-06-07T05:40:58.367-04:00 Polarity.image priorSource: 55575!!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/7/2025 23:28' prior: 33599457!solve: board with: specs|height width result constraints magnetPairs trySolve|	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "height:= board size.width:= (board at: 1) size.result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ].constraints:= Dictionary new.constraints at: 'left' put: (specs at: 'left').constraints at: 'right' put: (specs at: 'right').constraints at: 'top' put: (specs at: 'top').constraints at: 'bottom' put: (specs at: 'bottom').	   	"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !----QUIT----2025-06-07T23:28:57.78-04:00 Polarity.image priorSource: 55575!----QUIT----2025-06-07T23:29:13.922-04:00 Polarity.image priorSource: 56689!----QUIT----2025-06-08T01:22:42.727-04:00 Polarity.image priorSource: 56766!!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/8/2025 23:26'!canPlace: result row: i column: j|leftb rightb topb bottomb bool|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size. (i-1) > topb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == #X ifFalse: [^false]].(j-1) > leftb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(j+1) > rightb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].^true.! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/8/2025 23:29' prior: 33611444!canPlace: result row: i column: j|leftb rightb topb bottomb bool|bool := true.leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size. (i-1) > topb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == #X ifFalse: [^false]].(j-1) > leftb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(j+1) > rightb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].^bool.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/8/2025 23:40'!direction: magnetpos	"comment stating purpose of class-side method"	"scope: class-variables  &  class-instance-variables"					| temporary variable names |magnetpos == #L ifTrue: [ 					 ]! !Polarity class removeSelector: #direction:!!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/8/2025 23:49'!canPlace: result on: board row: i column: j type: type|leftb rightb topb bottomb mag|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.(result at: i at: j) == #X ifTrue: [ 	mag:= (board at: i at: j) 		 ] ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == #X ifFalse: [^false]].(j-1) > leftb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(j+1) > rightb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].^true.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/8/2025 23:49' prior: 33610361!solve: board with: specs|height width result constraints magnetPairs trySolve|	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		(specs at: #left at: i) > 0 & (specs at: #top at: j) > 0 & (result at: i at: j) == #X ifTrue: [			( self canPlace: result row: i column: j type: #+) ifTrue: [  ]						].				  ]. 	]."Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.								  ]  ].	   	"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/8/2025 23:50'!canPlace: result on: board row: i column: j|leftb rightb topb bottomb mag|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.(result at: i at: j) == #X ifTrue: [ 	mag:= (board at: i at: j) 		 ] ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == #X ifFalse: [^false]].(j-1) > leftb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(j+1) > rightb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].^true.! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/8/2025 23:51' prior: 33612818!canPlace: result on: board row: i column: j type: posNeg|leftb rightb topb bottomb mag|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.(result at: i at: j) == #X ifTrue: [ 	mag:= (board at: i at: j) 		 ] ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == #X ifFalse: [^false]].(j-1) > leftb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].(j+1) > rightb ifTrue: [(result at: i-1) == #X ifFalse: [^false]].^true.! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/8/2025 23:56' prior: 33615411!canPlace: result on: board row: i column: j type: type|leftb rightb topb bottomb mag|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.(result at: i at: j) == #X ifTrue: [ 	mag:= (board at: i at: j) 		 ] ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) > leftb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(j+1) > rightb ifTrue: [(result at: i-1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/8/2025 23:56' prior: 33613460!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		(specs at: #left at: i) > 0 & (specs at: #top at: j) > 0 & (result at: i at: j) == #X ifTrue: [			( self canPlace: result row: i column: j type: '+') ifTrue: [  ]						].				  ]. 	]."Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.								  ]  ].	   	"1"  ^ #( '+-+-X-' '-+-+X+' 'XX+-+-' 'XX-+X+' '-+XXX-' )	! !Polarity class removeSelector: #canPlace:on:row:column:!Polarity class removeSelector: #canPlace:row:column:!!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 00:00'!validplacement: result on: board row: i column: j type: type|leftb rightb topb bottomb mag|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.(result at: i at: j) == #X ifTrue: [ 	mag:= (board at: i at: j) 		 ] ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) > leftb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(j+1) > rightb ifTrue: [(result at: i-1) == type ifTrue: [^false]].^true.! !Polarity class removeSelector: #canPlace:on:row:column:type:!!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 00:10'!validplacement: result row: i column: j type: type|leftb rightb topb bottomb mag|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.(result at: i at: j) == #X ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) > leftb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(j+1) > rightb ifTrue: [(result at: i-1) == type ifTrue: [^false]].^true.! !Polarity class removeSelector: #validplacement:on:row:column:type:!!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 00:18' prior: 33618790!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.(result at: i at: j) == #X ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) > leftb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(j+1) > rightb ifTrue: [(result at: i-1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:21'!canPlace: result on: board row:i column: j type: type|pos |pos := board at: i at: j.pos == #L ifTrue: [ (self validplacement: result row: i column: j+1 type: #-) ifTrue: [^true] ifFalse: [^false]].pos == #R ifTrue: [ (self validplacement: result row: i column: j-1 type: #-) ifTrue: [^true] ifFalse: [^false]].			pos == #T ifTrue: [ (self validplacement: result row: i+1 column: j type: #-) ifTrue: [^true] ifFalse: [^false]].pos == #B ifTrue: [ (self validplacement: result row: i-1 column: j type: #-) ifTrue: [^true] ifFalse: [^false]].! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 00:21' prior: 33620023!canPlace: result on: board row:i column: j type: type|pos |pos := board at: i at: j.pos == #L ifTrue: [ (self validplacement: result row: i column: j+1 type: #-) ifTrue: [^true] ifFalse: [^false]].pos == #R ifTrue: [ (self validplacement: result row: i column: j-1 type: #-) ifTrue: [^true] ifFalse: [^false]].			pos == #T ifTrue: [ (self validplacement: result row: i+1 column: j type: #-) ifTrue: [^true] ifFalse: [^false]].pos == #B ifTrue: [ (self validplacement: result row: i-1 column: j type: #-) ifTrue: [^true] ifFalse: [^false]].^false! !!ManifestCPS506 commentStamp: '<historical>' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 00:21'!ruleExcessiveArgumentsRuleV1FalsePositive	^ #()! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 00:21' prior: 33621633!ruleExcessiveArgumentsRuleV1FalsePositive	^ #(#(#(#RGMetaclassDefinition #(#'Polarity class' #Polarity)) #'2025-06-09T00:21:29.073-04:00') )! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:27'!place: type on: result with: pos at: i and: j	"comment stating purpose of class-side method"	"scope: class-variables  &  class-instance-variables"				pos == #L ifTrue: [].pos == #R ifTrue: [].		pos == #T ifTrue: [].pos == #B ifTrue: []! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:29' prior: 33616689!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		(specs at: #left at: i) not = 0 & (specs at: #top at: j) not = 0 & (result at: i at: j) == #X ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: (board at: i at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.								  ]  ].	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:41' prior: 33622023!place: type on: result with: pos at: i and: j|notType|type == #+ ifTrue: [notType := #- ].type == #- ifTrue: [notType := #+ ].			pos == #L ifTrue: [(result at i at: j) = type and: (result at i at: j+1) = notType ].pos == #R ifTrue: [].		pos == #T ifTrue: [].pos == #B ifTrue: []! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:41' prior: 33623814!place: type on: result with: pos at: i and: j|notType|type == #+ ifTrue: [notType := #- ].type == #- ifTrue: [notType := #+ ].			pos == #L ifTrue: [(result at: i at: j) = type and: (result at: i at: j+1) = notType ].pos == #R ifTrue: [].		pos == #T ifTrue: [].pos == #B ifTrue: []! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:42' prior: 33624211!place: type on: result with: pos at: i and: j|notType|type == #+ ifTrue: [notType := #- ].type == #- ifTrue: [notType := #+ ].			pos == #L ifTrue: [(result at: i at: j) = type and: (result at: i at: j+1) = notType ].pos == #R ifTrue: [(result at: i at: j) = type and: (result at: i at: j-1) = notType ].		pos == #T ifTrue: [(result at: i at: j) = type and: (result at: i+1 at: j) = notType ].pos == #B ifTrue: [(result at: i at: j) = type and: (result at: i-1 at: j) = notType ].! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:42' prior: 33624610!place: type on: result with: pos at: i and: j|notType|type == #+ ifTrue: [notType := #- ].type == #- ifTrue: [notType := #+ ].			pos == #L ifTrue: [(result at: i at: j) = type and: (result at: i at: j+1) = notType ].pos == #R ifTrue: [(result at: i at: j) = type and: (result at: i at: j-1) = notType ].		pos == #T ifTrue: [(result at: i at: j) = type and: (result at: i+1 at: j) = notType ].pos == #B ifTrue: [(result at: i at: j) = type and: (result at: i-1 at: j) = notType ].^result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:43' prior: 33622374!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		(specs at: #left at: i) not = 0 & (specs at: #top at: j) not = 0 & (result at: i at: j) == #X ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: (board at: i at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		(specs at: #right at: i) not = 0 & (specs at: #bottom at: j) not = 0 & (result at: i at: j) == #X ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: (board at: i at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:45' prior: 33625815!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		(specs at: #left at: i) not = 0 & (specs at: #top at: j) not = 0 & (result at: i at: j) == #X ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: (board at: i at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (result at: i at: j) == #X ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: (board at: i at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:46' prior: 33627666!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (result at: i at: j) == #X ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: (board at: i at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (result at: i at: j) == #X ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: (board at: i at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:46' prior: 33629521!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & ((result at: i at: j) == #X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: (board at: i at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & ((result at: i at: j) == #X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: (board at: i at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:53' prior: 33631380!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == #X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == #X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 00:54' prior: 33619445!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == #X ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) > leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) > rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:55' prior: 33625208!place: type on: result with: pos at: i and: j|notType|type == #+ ifTrue: [notType := #- ].type == #- ifTrue: [notType := #+ ].			pos == #L ifTrue: [((result at: i) at: j) = type and: (result at: i at: j+1) = notType ].pos == #R ifTrue: [((result at: i) at: j) = type and: (result at: i at: j-1) = notType ].		pos == #T ifTrue: [((result at: i) at: j) = type and: (result at: i+1 at: j) = notType ].pos == #B ifTrue: [((result at: i) at: j) = type and: (result at: i-1 at: j) = notType ].^result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:55' prior: 33635712!place: type on: result with: pos at: i and: j|notType|type == #+ ifTrue: [notType := #- ].type == #- ifTrue: [notType := #+ ].			pos == #L ifTrue: [((result at: i) at: j) = type and: ((result at: i) at: j+1) = notType ].pos == #R ifTrue: [((result at: i) at: j) = type and: ((result at: i) at: j-1) = notType ].		pos == #T ifTrue: [((result at: i) at: j) = type and: ((result at: i+1) at: j) = notType ].pos == #B ifTrue: [((result at: i) at: j) = type and: ((result at: i-1) at: j) = notType ].^result! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 00:55' prior: 33620668!canPlace: result on: board row:i column: j type: type|pos |pos :=((board at: i) at: j).pos == #L ifTrue: [ (self validplacement: result row: i column: j+1 type: #-) ifTrue: [^true] ifFalse: [^false]].pos == #R ifTrue: [ (self validplacement: result row: i column: j-1 type: #-) ifTrue: [^true] ifFalse: [^false]].			pos == #T ifTrue: [ (self validplacement: result row: i+1 column: j type: #-) ifTrue: [^true] ifFalse: [^false]].pos == #B ifTrue: [ (self validplacement: result row: i-1 column: j type: #-) ifTrue: [^true] ifFalse: [^false]].^false! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 00:59' prior: 33633243!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == #X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				Transcript show: 'I got here'.				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == #X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [				Transcript show: 'Also here'.				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:13' prior: 33637606!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [ 				Transcript show: 'I got here'.				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: 'i') ifTrue: [				Transcript show: 'Also here'.				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 01:13' prior: 33635102!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) > leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) > rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:14' prior: 33636327!place: type on: result with: pos at: i and: j|notType|type == $+ ifTrue: [notType := $- ].type == $- ifTrue: [notType := $+ ].			pos == $L ifTrue: [((result at: i) at: j) = type and: ((result at: i) at: j+1) = notType ].pos == $R ifTrue: [((result at: i) at: j) = type and: ((result at: i) at: j-1) = notType ].		pos == $T ifTrue: [((result at: i) at: j) = type and: ((result at: i+1) at: j) = notType ].pos == $B ifTrue: [((result at: i) at: j) = type and: ((result at: i-1) at: j) = notType ].^result! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 01:14' prior: 33636938!canPlace: result on: board row:i column: j type: type|pos |pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: $-) ifTrue: [^true] ifFalse: [^false]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: $-) ifTrue: [^true] ifFalse: [^false]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: $-) ifTrue: [^true] ifFalse: [^false]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: $-) ifTrue: [^true] ifFalse: [^false]].^false! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:15' prior: 33639545!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: '+') ifTrue: [ 				Transcript show: 'I got here'.				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '-') & (self canPlace: result on: board row: i column: j type: '-') ifTrue: [				Transcript show: 'Also here'.				result := self place: '-' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:16' prior: 33643361!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: '+') ifTrue: [ 				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '-') & (self canPlace: result on: board row: i column: j type: '-') ifTrue: [				result := self place: '-' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 01:19' prior: 33641472!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].Transcript show: $T.(i-1) > topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].Transcript show: $B.(i+1) > bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].Transcript show: $L.(j-1) > leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].Transcript show: $R.(j+1) > rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 01:20' prior: 33647158!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].Transcript show: $T.(i-1) > topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].Transcript show: $B.(i+1) > bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].Transcript show: $L.(j-1) > leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].Transcript show: $R.(j+1) > rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].Transcript cr.^true.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:23' prior: 33645300!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: '+') ifTrue: [ 				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				Transcript show: 'i: ', i printString, ' left size: ', ((specs at: #left) size) printString; cr.Transcript show: 'j: ', j printString, ' top size: ', ((specs at: #top) size) printString; cr.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '-') & (self canPlace: result on: board row: i column: j type: '-') ifTrue: [				result := self place: '-' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 01:23' prior: 33647837!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 0.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].(i-1) > topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) > bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) > leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) > rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:26' prior: 33642082!place: type on: result with: pos at: i and: j|notType|type == $+ ifTrue: [notType := $- ].type == $- ifTrue: [notType := $+ ].			pos == $L ifTrue: [((result at: i) at: j put: type) and: ((result at: i) at: j+1 put: notType) ].pos == $R ifTrue: [((result at: i) at: j put: type) and: ((result at: i) at: j-1 put: notType) ].		pos == $T ifTrue: [((result at: i) at: j put: type) and: ((result at: i+1) at: j put: notType)].pos == $B ifTrue: [((result at: i) at: j put: type) and: ((result at: i-1) at: j put: notType) ].^result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:30' prior: 33651207!place: type on: result with: pos at: i and: j	| notType row rowCopy row2 row2Copy |	type = $+ ifTrue: [ notType := $- ].	type = $- ifTrue: [ notType := $+ ].	pos = $L ifTrue: [		row := result at: i.		rowCopy := row copy.		rowCopy at: j put: type.		rowCopy at: j + 1 put: notType.		result at: i put: rowCopy	].	pos = $R ifTrue: [		row := result at: i.		rowCopy := row copy.		rowCopy at: j put: type.		rowCopy at: j - 1 put: notType.		result at: i put: rowCopy	].	pos = $T ifTrue: [		row := result at: i.		rowCopy := row copy.		rowCopy at: j put: type.		result at: i put: rowCopy.		row2 := result at: i + 1.		row2Copy := row2 copy.		row2Copy at: j put: notType.		result at: i + 1 put: row2Copy	].	pos = $B ifTrue: [		row := result at: i.		rowCopy := row copy.		rowCopy at: j put: type.		result at: i put: rowCopy.		row2 := result at: i - 1.		row2Copy := row2 copy.		row2Copy at: j put: notType.		result at: i - 1 put: row2Copy	].	^ result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:39' prior: 33651853!place: type on: result with: pos at: i and: j    | notType row newRow row2 newRow2 |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    pos = $L ifTrue: [        row := result at: i.        "Replace characters at j and j+1 with type and notType"        newRow := (row copyFrom: 1 to: j - 1)            , (String with: type , notType)            , (row copyFrom: j + 2 to: row size).        result at: i put: newRow.    ].    pos = $R ifTrue: [        row := result at: i.        "Replace characters at j-1 and j"        newRow := (row copyFrom: 1 to: j - 2)            , (String with: notType , type)            , (row copyFrom: j + 1 to: row size).        result at: i put: newRow.    ].    pos = $T ifTrue: [        "Modify two rows: i and i+1, at column j"        row := result at: i.        newRow := (row copyFrom: 1 to: j - 1)            , (String with: type)            , (row copyFrom: j + 1 to: row size).        result at: i put: newRow.        row2 := result at: i + 1.        newRow2 := (row2 copyFrom: 1 to: j - 1)            , (String with: notType)            , (row2 copyFrom: j + 1 to: row2 size).        result at: i + 1 put: newRow2.    ].    pos = $B ifTrue: [        "Modify two rows: i and i-1, at column j"        row := result at: i.        newRow := (row copyFrom: 1 to: j - 1)            , (String with: type)            , (row copyFrom: j + 1 to: row size).        result at: i put: newRow.        row2 := result at: i - 1.        newRow2 := (row2 copyFrom: 1 to: j - 1)            , (String with: notType)            , (row2 copyFrom: j + 1 to: row2 size).        result at: i - 1 put: newRow2.    ].    ^ result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:40' prior: 33652945!place: type on: result with: pos at: i and: j    | notType row newRow row2 newRow2 resultSize |    resultSize := result size.    (i < 1 or: [i > resultSize]) ifTrue: [         ^ self error: 'Row index i out of bounds: ', i printString ].    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    pos = $L ifTrue: [        row := result at: i.        (j < 1 or: [j + 1 > row size]) ifTrue: [             ^ self error: 'Column index j out of bounds for L position: ', j printString ].        newRow := (row copyFrom: 1 to: j - 1)            , (String with: type , notType)            , (row copyFrom: j + 2 to: row size).        result at: i put: newRow.    ].    pos = $R ifTrue: [        row := result at: i.        (j - 1 < 1 or: [j > row size]) ifTrue: [             ^ self error: 'Column index j out of bounds for R position: ', j printString ].        newRow := (row copyFrom: 1 to: j - 2)            , (String with: notType , type)            , (row copyFrom: j + 1 to: row size).        result at: i put: newRow.    ].    pos = $T ifTrue: [        (i + 1 > resultSize) ifTrue: [             ^ self error: 'Row index i+1 out of bounds for T position: ', (i+1) printString ].        row := result at: i.        (j < 1 or: [j > row size]) ifTrue: [             ^ self error: 'Column index j out of bounds for T position: ', j printString ].        newRow := (row copyFrom: 1 to: j - 1)            , (String with: type)            , (row copyFrom: j + 1 to: row size).        result at: i put: newRow.        row2 := result at: i + 1.        newRow2 := (row2 copyFrom: 1 to: j - 1)            , (String with: notType)            , (row2 copyFrom: j + 1 to: row2 size).        result at: i + 1 put: newRow2.    ].    pos = $B ifTrue: [        (i - 1 < 1) ifTrue: [             ^ self error: 'Row index i-1 out of bounds for B position: ', (i-1) printString ].        row := result at: i.        (j < 1 or: [j > row size]) ifTrue: [             ^ self error: 'Column index j out of bounds for B position: ', j printString ].        newRow := (row copyFrom: 1 to: j - 1)            , (String with: type)            , (row copyFrom: j + 1 to: row size).        result at: i put: newRow.        row2 := result at: i - 1.        newRow2 := (row2 copyFrom: 1 to: j - 1)            , (String with: notType)            , (row2 copyFrom: j + 1 to: row2 size).        result at: i - 1 put: newRow2.    ].    ^ result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:42' prior: 33654781!place: type on: result with: pos at: i and: j    | notType row newRow row2 newRow2 resultSize |Transcript show: 'Got here'.    resultSize := result size.    (i < 1 or: [i > resultSize]) ifTrue: [         ^ self error: 'Row index i out of bounds: ', i printString ].    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    pos = $L ifTrue: [        row := result at: i.        (j < 1 or: [j + 1 > row size]) ifTrue: [             ^ self error: 'Column index j out of bounds for L position: ', j printString ].        newRow := (row copyFrom: 1 to: j - 1)            , (String with: type , notType)            , (row copyFrom: j + 2 to: row size).        result at: i put: newRow.    ].    pos = $R ifTrue: [        row := result at: i.        (j - 1 < 1 or: [j > row size]) ifTrue: [             ^ self error: 'Column index j out of bounds for R position: ', j printString ].        newRow := (row copyFrom: 1 to: j - 2)            , (String with: notType , type)            , (row copyFrom: j + 1 to: row size).        result at: i put: newRow.    ].    pos = $T ifTrue: [        (i + 1 > resultSize) ifTrue: [             ^ self error: 'Row index i+1 out of bounds for T position: ', (i+1) printString ].        row := result at: i.        (j < 1 or: [j > row size]) ifTrue: [             ^ self error: 'Column index j out of bounds for T position: ', j printString ].        newRow := (row copyFrom: 1 to: j - 1)            , (String with: type)            , (row copyFrom: j + 1 to: row size).        result at: i put: newRow.        row2 := result at: i + 1.        newRow2 := (row2 copyFrom: 1 to: j - 1)            , (String with: notType)            , (row2 copyFrom: j + 1 to: row2 size).        result at: i + 1 put: newRow2.    ].    pos = $B ifTrue: [        (i - 1 < 1) ifTrue: [             ^ self error: 'Row index i-1 out of bounds for B position: ', (i-1) printString ].        row := result at: i.        (j < 1 or: [j > row size]) ifTrue: [             ^ self error: 'Column index j out of bounds for B position: ', j printString ].        newRow := (row copyFrom: 1 to: j - 1)            , (String with: type)            , (row copyFrom: j + 1 to: row size).        result at: i put: newRow.        row2 := result at: i - 1.        newRow2 := (row2 copyFrom: 1 to: j - 1)            , (String with: notType)            , (row2 copyFrom: j + 1 to: row2 size).        result at: i - 1 put: newRow2.    ].    ^ result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:43' prior: 33657389!place: type on: result with: pos at: i and: j    | row newRow |    row := result at: i.    Transcript show: 'Original row: ', row; cr.    newRow := (row copyFrom: 1 to: j - 1)        , ($S asString)        , (row copyFrom: j + 1 to: row size).    result at: i put: newRow.    Transcript show: 'New row: ', newRow; cr.    ^result! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 01:45' prior: 33650596!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].(i-1) >= topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 01:47' prior: 33642693!canPlace: result on: board row:i column: j type: type|pos |pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: $-)].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: $-)].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: $-)].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: $-)].^false ! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:50' prior: 33660026!place: type on: result with: pos at: i and: j    | notType oldRow newRow belowRow belowNewRow aboveRow aboveNewRow |    notType := type = $+ ifTrue: [ $- ] ifFalse: [ $+ ].        oldRow := result at: i.        pos = $L ifTrue: [        newRow := oldRow copyReplaceFrom: j to: j with: (String with: type).        newRow := newRow copyReplaceFrom: j + 1 to: j + 1 with: (String with: notType).        result at: i put: newRow.        ^result    ].        pos = $R ifTrue: [        newRow := oldRow copyReplaceFrom: j to: j with: (String with: type).        newRow := newRow copyReplaceFrom: j - 1 to: j - 1 with: (String with: notType).        result at: i put: newRow.        ^result    ].        pos = $T ifTrue: [        "Replace (i,j) and (i+1,j)"        newRow := oldRow copyReplaceFrom: j to: j with: (String with: type).        result at: i put: newRow.                belowRow := result at: i + 1.        belowNewRow := belowRow copyReplaceFrom: j to: j with: (String with: notType).        result at: i + 1 put: belowNewRow.        ^result    ].        pos = $B ifTrue: [        "Replace (i,j) and (i-1,j)"        newRow := oldRow copyReplaceFrom: j to: j with: (String with: type).        result at: i put: newRow.                aboveRow := result at: i - 1.        aboveNewRow := aboveRow copyReplaceFrom: j to: j with: (String with: notType).        result at: i - 1 put: aboveNewRow.        ^result    ].        ^result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:51' prior: 33661596!place: type on: result with: pos at: i and: j    | notType oldRow newRow belowRow belowNewRow aboveRow aboveNewRow |    notType := type = $+ ifTrue: [ $- ] ifFalse: [ $+ ].        oldRow := result at: i.        pos = $L ifTrue: [        newRow := oldRow copyReplaceFrom: j to: j with: (String with: type).        newRow := newRow copyReplaceFrom: j + 1 to: j + 1 with: (String with: notType).        result at: i put: newRow.			Transcript show: result cr.        ^result    ].        pos = $R ifTrue: [        newRow := oldRow copyReplaceFrom: j to: j with: (String with: type).        newRow := newRow copyReplaceFrom: j - 1 to: j - 1 with: (String with: notType).        result at: i put: newRow.			Transcript show: result cr.        ^result    ].        pos = $T ifTrue: [        "Replace (i,j) and (i+1,j)"        newRow := oldRow copyReplaceFrom: j to: j with: (String with: type).        result at: i put: newRow.                belowRow := result at: i + 1.        belowNewRow := belowRow copyReplaceFrom: j to: j with: (String with: notType).        result at: i + 1 put: belowNewRow.Transcript show: result cr.        ^result    ].        pos = $B ifTrue: [        "Replace (i,j) and (i-1,j)"        newRow := oldRow copyReplaceFrom: j to: j with: (String with: type).        result at: i put: newRow.                aboveRow := result at: i - 1.        aboveNewRow := aboveRow copyReplaceFrom: j to: j with: (String with: notType).        result at: i - 1 put: aboveNewRow.Transcript show: result cr.        ^result    ].        ^result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:52' prior: 33648542!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: '+') ifTrue: [ 				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				Transcript show: 'i: ', i printString, ' left size: ', ((specs at: #left) size) printString; cr.				Transcript show: 'j: ', j printString, ' top size: ', ((specs at: #top) size) printString; cr.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '-') & (self canPlace: result on: board row: i column: j type: '-') ifTrue: [				result := self place: '-' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:53' prior: 33664880!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: '+') ifTrue: [ 				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				Transcript show: 'i: ', i printString, ' left size: ', ((specs at: #left) size) printString; cr.				Transcript show: 'j: ', j printString, ' top size: ', ((specs at: #top) size) printString; cr.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '-') & (self canPlace: result on: board row: i column: j type: '-') ifTrue: [				result := self place: '-' on: result with: ((board at: i) at: j) at: i and: j.				Transcript show: 'i: ', i printString, ' left size: ', ((specs at: #left) size) printString; cr.				Transcript show: 'j: ', j printString, ' top size: ', ((specs at: #top) size) printString; cr.				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'testing' stamp: 'SulemanDawood 6/9/2025 01:56' prior: 33661063!canPlace: result on: board row:i column: j type: type|pos |pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: $-) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: $-)ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: $-)ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: $-)ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:57' prior: 33666950!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: '+') ifTrue: [ 				Transcript show: 'i: ', i printString, ' left size: ', ((specs at: #left) size) printString; cr.				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				Transcript show: 'j: ', j printString, ' top size: ', ((specs at: #top) size) printString; cr.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '-') & (self canPlace: result on: board row: i column: j type: '-') ifTrue: [				result := self place: '-' on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 01:59' prior: 33663179!place: type on: result with: pos at: i and: j|notType|type == $+ ifTrue: [notType := $- ].type == $- ifTrue: [notType := $+ ].			pos == $L ifTrue: [((result at: i) at: j put: type) and: ((result at: i) at: j+1 put: notType) ].pos == $R ifTrue: [((result at: i) at: j put: type) and: ((result at: i) at: j-1 put: notType) ].		pos == $T ifTrue: [((result at: i) at: j put: type) and: ((result at: i+1) at: j put: notType)].pos == $B ifTrue: [((result at: i) at: j put: type) and: ((result at: i-1) at: j put: notType) ].^result! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/9/2025 02:00' prior: 33669802!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '+') & (self canPlace: result on: board row: i column: j type: '+') ifTrue: [ 				result := self place: '+' on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '-') & (self canPlace: result on: board row: i column: j type: '-') ifTrue: [				result := self place: '-' on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 02:01'!ruleLongMethodsRuleV1FalsePositive	^ #()! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 02:01' prior: 33674381!ruleLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'Polarity class' #solve:with: #true)) #'2025-06-09T02:01:23.481-04:00') )! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 02:01'!ruleToDoRuleV1FalsePositive	^ #()! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 02:01' prior: 33674762!ruleToDoRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'Polarity class' #solve:with: #true)) #'2025-06-09T02:01:27.732-04:00') )! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 02:01'!ruleNotEliminationRuleV1FalsePositive	^ #()! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 02:01' prior: 33675129!ruleNotEliminationRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'Polarity class' #solve:with: #true)) #'2025-06-09T02:01:30.911-04:00') )! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 02:01'!ruleToDoCollectRuleV1FalsePositive	^ #()! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'SulemanDawood 6/9/2025 02:01' prior: 33675516!ruleToDoCollectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'Polarity class' #solve:with: #true)) #'2025-06-09T02:01:33.26-04:00') )! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 02:22' prior: 33671877!place: type on: result with: pos at: i and: j|notType lr t b |type == '+' ifTrue: [notType := '-' ].type == '-' ifTrue: [notType := '+' ].lr:= result at:i.t:= result at:i-1.b:= result at:i+1.pos == 'L' ifTrue: [((lr copyFrom: 1 to: j-1), type, (lr copyFrom: j+1 to: lr size)) and: (lr copyFrom: 1 to: j-1), notType, (lr copyFrom: j+1 to: lr size)].			pos == 'L' ifTrue: [((result at: i) at: j put: type) and: ((result at: i) at: j+1 put: notType) ].pos == 'R' ifTrue: [((result at: i) at: j put: type) and: ((result at: i) at: j-1 put: notType) ].		pos == 'T' ifTrue: [((result at: i) at: j put: type) and: ((result at: i+1) at: j put: notType)].pos == 'B' ifTrue: [((result at: i) at: j put: type) and: ((result at: i-1) at: j put: notType) ].^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 02:22' prior: 33660460!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == 'X' ifFalse: [ ^false].(i-1) >= topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !----QUIT----2025-06-09T02:30:15.007-04:00 Polarity.image priorSource: 56844!!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:22' prior: 33675902!place: type on: result with: pos at: i and: j|notType lr t b |type == $+ ifTrue: [notType := $- ].type == $- ifTrue: [notType := $+ ].lr:= result at:i.t:= result at:i-1.b:= result at:i+1.			pos == $L ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: (lr copyReplaceFrom: (j+1) to: (j+1) with: (notType asString)))].pos == $R ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: (lr copyReplaceFrom: (j-1) to: (j-1) with: (notType asString)))].			pos == $T ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i+1) put: (b copyReplaceFrom: (j) to: (j) with: (notType asString)))].pos == $B ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i-1) put: (t copyReplaceFrom: (j) to: (j) with: (notType asString)))].^result ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:23' prior: 33677451!place: type on: result with: pos at: i and: j| notType lr t b updatedRow updatedOtherRow |type = $+ ifTrue: [ notType := $- ].type = $- ifTrue: [ notType := $+ ].lr := result at: i.pos = $L ifTrue: [    "Update current row with type and notType"    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.    result at: i put: updatedRow.].pos = $R ifTrue: [    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.    result at: i put: updatedRow.].pos = $T ifTrue: [    t := result at: (i - 1).    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedOtherRow := t copyReplaceFrom: j to: j with: notType asString.    result at: i put: updatedRow.    result at: (i - 1) put: updatedOtherRow.].pos = $B ifTrue: [    b := result at: (i + 1).    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedOtherRow := b copyReplaceFrom: j to: j with: notType asString.    result at: i put: updatedRow.    result at: (i + 1) put: updatedOtherRow.].^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:25' prior: 33678506!place: type on: result with: pos at: i and: j| notType lr t b updatedRow updatedOtherRow |type = $+ ifTrue: [ notType := $- ].type = $- ifTrue: [ notType := $+ ].Transcript show: 'got here'.lr := result at: i.pos = $L ifTrue: [    "Update current row with type and notType"    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.    result at: i put: updatedRow.].pos = $R ifTrue: [    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.    result at: i put: updatedRow.].pos = $T ifTrue: [    t := result at: (i - 1).    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedOtherRow := t copyReplaceFrom: j to: j with: notType asString.    result at: i put: updatedRow.    result at: (i - 1) put: updatedOtherRow.].pos = $B ifTrue: [    b := result at: (i + 1).    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedOtherRow := b copyReplaceFrom: j to: j with: notType asString.    result at: i put: updatedRow.    result at: (i + 1) put: updatedOtherRow.].^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:26' prior: 33676768!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|Transcript show: 'got there'.leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == 'X' ifFalse: [ ^false].(i-1) >= topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:26' prior: 33669208!canPlace: result on: board row:i column: j type: type|pos |pos :=((board at: i) at: j).Transcript show: 'got here'.pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: $-) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: $-)ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: $-)ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: $-)ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:26' prior: 33681162!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == 'X' ifFalse: [ ^false].(i-1) >= topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:27' prior: 33682407!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == 'X' ifFalse: [ ^false].Transcript show: 'false'.(i-1) >= topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:27' prior: 33679820!place: type on: result with: pos at: i and: j| notType lr t b updatedRow updatedOtherRow |type = $+ ifTrue: [ notType := $- ].type = $- ifTrue: [ notType := $+ ].lr := result at: i.pos = $L ifTrue: [    "Update current row with type and notType"    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.    result at: i put: updatedRow.].pos = $R ifTrue: [    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.    result at: i put: updatedRow.].pos = $T ifTrue: [    t := result at: (i - 1).    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedOtherRow := t copyReplaceFrom: j to: j with: notType asString.    result at: i put: updatedRow.    result at: (i - 1) put: updatedOtherRow.].pos = $B ifTrue: [    b := result at: (i + 1).    updatedRow := lr copyReplaceFrom: j to: j with: type asString.    updatedOtherRow := b copyReplaceFrom: j to: j with: notType asString.    result at: i put: updatedRow.    result at: (i + 1) put: updatedOtherRow.].^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:28' prior: 33681796!canPlace: result on: board row:i column: j type: type|pos |pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: $-) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: $-)ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: $-)ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: $-)ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:28' prior: 33683011!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.Transcript show: 'true'.((result at: i) at: j) == 'X' ifFalse: [ ^false].Transcript show: 'false'.(i-1) >= topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:29' prior: 33685537!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.Transcript show: 'true'.((result at: i) at: j) == $X ifFalse: [ ^false].Transcript show: 'false'.(i-1) >= topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:29' prior: 33683641!place: type on: result with: pos at: i and: j|notType lr t b |type == $+ ifTrue: [notType := $- ].type == $- ifTrue: [notType := $+ ].lr:= result at:i.t:= result at:i-1.b:= result at:i+1.			pos == $L ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: (lr copyReplaceFrom: (j+1) to: (j+1) with: (notType asString)))].pos == $R ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: (lr copyReplaceFrom: (j-1) to: (j-1) with: (notType asString)))].			pos == $T ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i+1) put: (b copyReplaceFrom: (j) to: (j) with: (notType asString)))].pos == $B ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i-1) put: (t copyReplaceFrom: (j) to: (j) with: (notType asString)))].^result ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:32' prior: 33686846!place: type on: result with: pos at: i and: j|notType lr t b |type == $+ ifTrue: [notType := $- ].type == $- ifTrue: [notType := $+ ].lr:= result at:i.t:= result at:i-1.b:= result at:i+1.Transcript show: pos.			pos == $L ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: (lr copyReplaceFrom: (j+1) to: (j+1) with: (notType asString)))].Transcript show: pos.pos == $R ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: (lr copyReplaceFrom: (j-1) to: (j-1) with: (notType asString)))].	Transcript show: pos.pos == $T ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i+1) put: (b copyReplaceFrom: (j) to: (j) with: (notType asString)))].Transcript show: pos.pos == $B ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i-1) put: (t copyReplaceFrom: (j) to: (j) with: (notType asString)))].^result ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:32' prior: 33686192!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].(i-1) >= topb ifTrue: [(result at: i-1) == type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [(result at: i+1) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:32' prior: 33687901!place: type on: result with: pos at: i and: j|notType lr t b |type == $+ ifTrue: [notType := $- ].type == $- ifTrue: [notType := $+ ].Transcript show: pos.lr:= result at:i.t:= result at:i-1.b:= result at:i+1.Transcript show: pos.			pos == $L ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: (lr copyReplaceFrom: (j+1) to: (j+1) with: (notType asString)))].Transcript show: pos.pos == $R ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: (lr copyReplaceFrom: (j-1) to: (j-1) with: (notType asString)))].	Transcript show: pos.pos == $T ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i+1) put: (b copyReplaceFrom: (j) to: (j) with: (notType asString)))].Transcript show: pos.pos == $B ifTrue: [((result at: i) put: (lr copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i-1) put: (t copyReplaceFrom: (j) to: (j) with: (notType asString)))].^result ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:35' prior: 33689641!place: type on: result with: pos at: i and: j|notType lr t b |type == $+ ifTrue: [notType := $- ].type == $- ifTrue: [notType := $+ ].		pos == $L ifTrue: [((result at: i) put: ((result at: i) copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: ((result at: i) copyReplaceFrom: (j+1) to: (j+1) with: (notType asString)))].pos == $R ifTrue: [((result at: i) put: ((result at: i) copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: ((result at: i) copyReplaceFrom: (j-1) to: (j-1) with: (notType asString)))].	pos == $T ifTrue: [((result at: i) put: ((result at: i) copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i+1) put: ((result at: i+1) copyReplaceFrom: (j) to: (j) with: (notType asString)))].pos == $B ifTrue: [((result at: i) put: ((result at: i) copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i-1) put: ((result at: i-1) copyReplaceFrom: (j) to: (j) with: (notType asString)))].^result ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:35' prior: 33690800!place: type on: result with: pos at: i and: j|notType |type == $+ ifTrue: [notType := $- ].type == $- ifTrue: [notType := $+ ].		pos == $L ifTrue: [((result at: i) put: ((result at: i) copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: ((result at: i) copyReplaceFrom: (j+1) to: (j+1) with: (notType asString)))].pos == $R ifTrue: [((result at: i) put: ((result at: i) copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i) put: ((result at: i) copyReplaceFrom: (j-1) to: (j-1) with: (notType asString)))].	pos == $T ifTrue: [((result at: i) put: ((result at: i) copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i+1) put: ((result at: i+1) copyReplaceFrom: (j) to: (j) with: (notType asString)))].pos == $B ifTrue: [((result at: i) put: ((result at: i) copyReplaceFrom: j to: j with: (type asString))) 	and: ((result at: i-1) put: ((result at: i-1) copyReplaceFrom: (j) to: (j) with: (notType asString)))].^result ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:37' prior: 33691898!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:38' prior: 33692989!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].Transcript show: $f.    updatedRow := result at: i.Transcript show: $e.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:38' prior: 33694460!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: $e.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:41' prior: 33695971!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: pos.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.        result at: i put: updatedRow.    ].Transcript show: pos.    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].Transcript show: pos.    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].Transcript show: pos.    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:43' prior: 33697462!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i, '', j.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:43' prior: 33699017!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i asString, '', j asString.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:46' prior: 33684955!canPlace: result on: board row:i column: j type: ty|pos notType |pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: notType) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: notType)ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: notType)ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: notType)ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:46' prior: 33702029!canPlace: result on: board row:i column: j type: type|pos notType |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: notType) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: notType)ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: notType)ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: notType)ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:46' prior: 33702637!canPlace: result on: board row:i column: j type: type|pos notType |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: notType) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: notType)ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: notType)ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: notType)ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:47' prior: 33700514!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i asString, '', j asString cr.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:47' prior: 33704023!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i asString, '', j asString; cr.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:48' prior: 33705541!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i asString, '', j asString; cr.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:51' prior: 33707060!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i asString, '', j asString; cr.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: (notType asString).        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:53' prior: 33708607!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i asString, '', j asString; cr.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType .        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:53' prior: 33710158!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i asString, '', j asString; cr.    pos = $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos = $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos = $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos = $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:54' prior: 33711699!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i asString, '', j asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:55' prior: 33713249!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: i asString, '', j asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (notType asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:55' prior: 33714803!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type = $+ ifTrue: [ notType := $- ].    type = $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:56' prior: 33716360!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |type == $+ ifTrue: [ notType := $- ].type == $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:56' prior: 33703330!canPlace: result on: board row:i column: j type: type|pos notType |    type == $+ ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: notType) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: notType)ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: notType)ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: notType)ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:57' prior: 33719434!canPlace: result on: board row:i column: j type: type|pos notType |    type == ($+ asString)  ifTrue: [ notType := $- ].    type == ($- asString) ifTrue: [ notType := $+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: notType) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: notType)ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: notType)ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: notType)ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:57' prior: 33717900!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == ($+ asString)  ifTrue: [ notType := $- ].    type == ($- asString) ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:58' prior: 33720847!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == ($+ asString)  ifTrue: [ notType := $- ].    type == ($- asString) ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString, type asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:58' prior: 33722412!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == ($+ asString)  ifTrue: [ notType := $- ].    type == ($- asString) ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString, type asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:58' prior: 33723996!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == ($+ asString)  ifTrue: [ notType := #- ].    type == ($- asString) ifTrue: [ notType := #+ ].    updatedRow := result at: i.Transcript show: notType asString, type asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:58' prior: 33725581!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == (#+ asString)  ifTrue: [ notType := #- ].    type == (#- asString) ifTrue: [ notType := #+ ].    updatedRow := result at: i.Transcript show: notType asString, type asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:58' prior: 33720129!canPlace: result on: board row:i column: j type: type|pos notType |    type == (#+ asString)  ifTrue: [ notType := #- ].    type == (#- asString) ifTrue: [ notType := #+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: notType) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: notType)ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: notType)ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: notType)ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 22:59' prior: 33728751!canPlace: result on: board row:i column: j type: type|pos notType |    type == (#+ asString)  ifTrue: [ notType := #- ].    type == (#- asString) ifTrue: [ notType := #+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: (notType asString)) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: (notType asString))ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: (notType asString))ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: (notType asString))ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:00' prior: 33729469!canPlace: result on: board row:i column: j type: type|pos notType |    type == ($+ asString)  ifTrue: [ notType := $- ].    type == ($- asString) ifTrue: [ notType := $+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: (notType asString)) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: (notType asString))ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: (notType asString))ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: (notType asString))ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:00' prior: 33727166!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == ($+ asString)  ifTrue: [ notType := $A ].    type == ($- asString) ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString, type asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:00' prior: 33730993!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == ($+ asString)  ifTrue: [ notType := $A ].    type == ($- asString) ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString, type asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:02' prior: 33732578!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == $+   ifTrue: [ notType := $A ].    type == ($- asString) ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString, type asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:02' prior: 33672523!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: '+') ifTrue: [ 				result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '-') & (self canPlace: result on: board row: i column: j type: '-') ifTrue: [				result := self place: '-' on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:03' prior: 33735738!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: '-') & (self canPlace: result on: board row: i column: j type: '-') ifTrue: [				result := self place: '-' on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:03' prior: 33737600!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:03' prior: 33734163!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == $+   ifTrue: [ notType := $A ].    type == $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString, type asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:03' prior: 33741319!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == $+   ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.Transcript show: notType asString, type asString; cr.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/9/2025 23:03' prior: 33730231!canPlace: result on: board row:i column: j type: type|pos notType |    type == $+   ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: (notType asString)) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: (notType asString))ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: (notType asString))ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: (notType asString))ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/10/2025 01:05'!withinbounds: specs at: i and: j with: type and: pos|notType|type == $+   ifTrue: [ notType := $- ].type == $- ifTrue: [ notType := $+ ].pos == $L ifTrue: [ notType == $+ ifTrue: [((specs at: #left at: i) ~= 0) & ((specs at: #top at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((specs at: #right at: i) ~= 0) & ((specs at: #bottom at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $R ifTrue: [ notType == $+ ifTrue: [((specs at: #left at: i) ~= 0) & ((specs at: #top at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((specs at: #right at: i) ~= 0) & ((specs at: #bottom at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $T ifTrue: [ notType == $+ ifTrue: [((specs at: #left at: i+1) ~= 0) & ((specs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((specs at: #right at: i+1) ~= 0) & ((specs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $B ifTrue: [ notType == $+ ifTrue: [((specs at: #left at: i-1) ~= 0) & ((specs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((specs at: #right at: i-1) ~= 0) & ((specs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/10/2025 01:06' prior: 33745184!withinbounds: specs at: i and: j with: type and: pos|notType|type == $+   ifTrue: [ notType := $- ].type == $- ifTrue: [ notType := $+ ].pos == $L ifTrue: [ notType == $+ ifTrue: [((specs at: #left at: i) ~= 0) & ((specs at: #top at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((specs at: #right at: i) ~= 0) & ((specs at: #bottom at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $R ifTrue: [ notType == $+ ifTrue: [((specs at: #left at: i) ~= 0) & ((specs at: #top at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((specs at: #right at: i) ~= 0) & ((specs at: #bottom at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $T ifTrue: [ notType == $+ ifTrue: [((specs at: #left at: i+1) ~= 0) & ((specs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((specs at: #right at: i+1) ~= 0) & ((specs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $B ifTrue: [ notType == $+ ifTrue: [((specs at: #left at: i-1) ~= 0) & ((specs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((specs at: #right at: i-1) ~= 0) & ((specs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].^false.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 01:07' prior: 33739461!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: specs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/10/2025 01:13'!updateSpecs: specs at: i and: j given: pos! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/10/2025 03:37'!updateSpecs: specs at: i and: j given: pos andType: typetype == $+ ifTrue: [pos == $L ifTrue: [				specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j+1 put: ((specs at: #bottom at: j+1)-1).		^specs	].	pos == $R ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j-1 put: ((specs at: #bottom at: j-1)-1).		^specs	].	pos == $T ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i+1 put: ((specs at: #right at: i+1)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $B ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].].type == $- ifTrue: [pos == $L ifTrue: [				specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j+1 put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $R ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #left at: i)-1).		specs at: #bottom at: j-1 put: ((specs at: #top at: j)-1).		^specs	].	pos == $T ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #left at: i)-1).		specs at: #bottom at: j put: ((specs at: #top at: j)-1).		^specs	].	pos == $B ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #left at: i)-1).		specs at: #bottom at: j put: ((specs at: #top at: j)-1).		^specs	].].^specs! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/10/2025 03:45' prior: 33749976!updateSpecs: specs at: i and: j given: pos andType: typetype == $+ ifTrue:[		pos == $L ifTrue: [				specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j+1 put: ((specs at: #bottom at: j+1)-1).		^specs	].	pos == $R ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j-1 put: ((specs at: #bottom at: j-1)-1).		^specs	].	pos == $T ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i+1 put: ((specs at: #right at: i+1)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $B ifTrue: [ 		specs at: #left at: i+1 put: ((specs at: #left at: i+1)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].].type == $- ifTrue: [		pos == $L ifTrue: [				specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j+1 put: ((specs at: #top at: j+1)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $R ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j-1 put: ((specs at: #top at: j-1)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $T ifTrue: [ 		specs at: #left at: i+1 put: ((specs at: #left at: i+1)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $B ifTrue: [ 		specs at: #left at: i-1 put: ((specs at: #left at: i-1)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].].^specs! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:46' prior: 33747886!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: specs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					specs = (self updateSpecs: specs at: i and: j given: ((board at: i) at: j)).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:46' prior: 33742883!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == $+   ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].Transcript show: result; cr.    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:46' prior: 33756847!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == $+   ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !Polarity class removeSelector: #updateSpecs:at:and:given:!!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/10/2025 03:48' prior: 33752380!updateSpecs: specs at: i and: j given: pos andType: typetype == $+ ifTrue:[		pos == $L ifTrue: [				specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j+1 put: ((specs at: #bottom at: j+1)-1).		^specs	].	pos == $R ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j-1 put: ((specs at: #bottom at: j-1)-1).		^specs	].	pos == $T ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i+1 put: ((specs at: #right at: i+1)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $B ifTrue: [ 		specs at: #left at: i+1 put: ((specs at: #left at: i+1)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].].type == $- ifTrue: [		pos == $L ifTrue: [				specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j+1 put: ((specs at: #top at: j+1)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $R ifTrue: [ 		specs at: #left at: i put: ((specs at: #left at: i)-1).		specs at: #top at: j-1 put: ((specs at: #top at: j-1)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $T ifTrue: [ 		specs at: #left at: i+1 put: ((specs at: #left at: i+1)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].	pos == $B ifTrue: [ 		specs at: #left at: i-1 put: ((specs at: #left at: i-1)-1).		specs at: #top at: j put: ((specs at: #top at: j)-1).		specs at: #right at: i put: ((specs at: #right at: i)-1).		specs at: #bottom at: j put: ((specs at: #bottom at: j)-1).		^specs	].].^specs! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:49' prior: 33754808!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: specs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					specs = (self updateSpecs: specs at: i and: j given: ((board at: i) at: j) andType: $+).					result = self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:49' prior: 33762338!solve: board with: specs|height width result |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #left at: i) = 0) not & ((specs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: specs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 (self updateSpecs: specs at: i and: j given: ((board at: i) at: j) andType: $+).					result = self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((specs at: #right at: i) = 0) not & ((specs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:53' prior: 33764388!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result = self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/10/2025 03:54' prior: 33759912!updateSpecs: mspecs at: i and: j given: pos andType: typetype == $+ ifTrue:[		pos == $L ifTrue: [				mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j+1 put: ((mspecs at: #bottom at: j+1)-1).		^mspecs	].	pos == $R ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j-1 put: ((mspecs at: #bottom at: j-1)-1).		^mspecs	].	pos == $T ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i+1 put: ((mspecs at: #right at: i+1)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $B ifTrue: [ 		mspecs at: #left at: i+1 put: ((mspecs at: #left at: i+1)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].].type == $- ifTrue: [		pos == $L ifTrue: [				mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j+1 put: ((mspecs at: #top at: j+1)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $R ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j-1 put: ((mspecs at: #top at: j-1)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $T ifTrue: [ 		mspecs at: #left at: i+1 put: ((mspecs at: #left at: i+1)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs  at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $B ifTrue: [ 		mspecs at: #left at: i-1 put: ((mspecs at: #left at: i-1)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].].^mspecs! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'SulemanDawood 6/10/2025 03:55' prior: 33746536!withinbounds: mspecs at: i and: j with: type and: pos|notType|type == $+   ifTrue: [ notType := $- ].type == $- ifTrue: [ notType := $+ ].pos == $L ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i) ~= 0) & ((mspecs at: #top at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i) ~= 0) & ((mspecs at: #bottom at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $R ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i) ~= 0) & ((mspecs at: #top at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i) ~= 0) & ((mspecs at: #bottom at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $T ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i+1) ~= 0) & ((mspecs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i+1) ~= 0) & ((mspecs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $B ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i-1) ~= 0) & ((mspecs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i-1) ~= 0) & ((mspecs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].^false.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:55' prior: 33766431!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:56' prior: 33772641!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: mspecs; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:58' prior: 33774962!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.								]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:00' prior: 33777317!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:16' prior: 33779672!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) or: ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: i) > 0) or: ((mspecs at: #right at: j) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:21' prior: 33782224!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"((leftVal ~= 0) and: [topVal ~= 0])  "neither can be zero"    & [((result at: i) at: j) = $X]  "position is free"    & [leftVal > 0 or: [topVal > 0]]  "at least one is positive"    ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm rightVal bottomVal|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"((bottomVal ~= 0) and: [rightVal ~= 0])  "neither can be zero"    & [((result at: i) at: j) = $X]  "position is free"    & [rightVal > 0 or: [bottomVal > 0]]  "at least one is positive"    ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:21' prior: 33784918!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"((leftVal ~= 0) and: [topVal ~= 0])  "neither can be zero"    & [((result at: i) at: j) = $X]  "position is free"    & [leftVal > 0 or: [topVal > 0]]  "at least one is positive"    ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm rightVal bottomVal|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"((bottomVal ~= 0) and: [rightVal ~= 0])  "neither can be zero"    & [((result at: i) at: j) = $X]  "position is free"    & [rightVal > 0 or: [bottomVal > 0]]  "at least one is positive"    ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:22' prior: 33787739!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"((leftVal ~= 0) and: [topVal ~= 0])  "neither can be zero"    & [((result at: i) at: j) = $X]  "position is free"    & [leftVal > 0 or: [topVal > 0]]  "at least one is positive"    ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm rightVal bottomVal|		colm:= row at: j.bottomVal  := mspecs at: #bottom at: j.rightVal := mspecs at: #right at: i.				"Check if polarity's are still greater than zero if so keep adding pieces"((bottomVal ~= 0) and: [rightVal ~= 0])  "neither can be zero"    & [((result at: i) at: j) = $X]  "position is free"    & [rightVal > 0 or: [bottomVal > 0]]  "at least one is positive"    ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:23' prior: 33790560!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) or: ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: i) > 0) or: ((mspecs at: #right at: j) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:25' prior: 33793459!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: i) > 0) | ((mspecs at: #right at: j) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:25' prior: 33796243!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: i) > 0) | ((mspecs at: #right at: j) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:26' prior: 33799023!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: i) > 0) | ((mspecs at: #right at: j) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:27' prior: 33801839!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) "& (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) "ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:27' prior: 33804625!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:42' prior: 33744447!canPlace: result on: board row:i column: j type: type|pos notType |    type == $+   ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: (notType)) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: (notType))ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: (notType))ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: (notType))ifTrue: [^true]].^false ! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:43' prior: 33689038!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].(i-1) >= topb ifTrue: [(result at: i-1) == (type asCharacter) ifTrue: [^false]].(i+1) <= bottomb ifTrue: [(result at: i+1) == (type asCharacter) ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == (type asCharacter) ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == (type asCharacter) ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:44' prior: 33810905!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].(i-1) >= topb ifTrue: [((result at: i-1) at: j)== type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [((result at: i+1)at:j) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:44' prior: 33811565!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].(i-1) >= topb ifTrue: [((result at: i-1) at: j)== type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [((result at: i+1)at: j) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:59' prior: 33807413!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. Transcript show: specs.	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:00' prior: 33812800!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. Transcript show: mspecs; cr.	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:03' prior: 33815610!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:06' prior: 33768762!updateSpecs: mspecs at: i and: j given: pos andType: typetype == $+ ifTrue:[		pos == $L ifTrue: [				mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j+1 put: ((mspecs at: #bottom at: j+1)-1).		^mspecs	].	pos == $R ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j-1 put: ((mspecs at: #bottom at: j-1)-1).		^mspecs	].	pos == $T ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i+1 put: ((mspecs at: #right at: i+1)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $B ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i-1 put: ((mspecs at: #right at: i-1)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].].type == $- ifTrue: [		pos == $L ifTrue: [				mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j+1 put: ((mspecs at: #top at: j+1)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $R ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j-1 put: ((mspecs at: #top at: j-1)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $T ifTrue: [ 		mspecs at: #left at: i+1 put: ((mspecs at: #left at: i+1)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs  at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $B ifTrue: [ 		mspecs at: #left at: i-1 put: ((mspecs at: #left at: i-1)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].].^mspecs! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:08' prior: 33818425!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					Transcript show: 'doing +'; cr.					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					Transcript show: 'doing -'; cr.										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:09' prior: 33823815!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					Transcript show: 'doing +'; cr.					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) not & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					Transcript show: 'doing -'; cr.										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:10' prior: 33826778!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					Transcript show: 'doing +'; cr.					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) = 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					Transcript show: 'doing -'; cr.										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:10' prior: 33829745!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					Transcript show: 'doing +'; cr.					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 					Transcript show: 'doing -'; cr.										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:13' prior: 33832708!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	   	"1"  ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:15' prior: 33835671!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	 ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:33' prior: 33838425!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. "Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. 	 ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:34' prior: 33841171!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	 ^result	! !!PolarityLogTest commentStamp: '<historical>' prior: 0!A PolarityLogTest is a test class for testing the behavior of PolarityLog!----QUIT----2025-06-10T23:03:25.66-04:00 Polarity.image priorSource: 122846!----QUIT/NOSAVE----2025-06-12T01:57:26.88-04:00 Polarity.image priorSource: 292270!----QUIT/NOSAVE----2025-06-12T02:18:08.733-04:00 Polarity.image priorSource: 292270!----QUIT/NOSAVE----2025-06-12T03:50:06.31-04:00 Polarity.image priorSource: 292270!!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/12/2025 23:02' prior: 33843919!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].						"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				].	]. "	 ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/12/2025 23:04' prior: 33847132!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].						"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	 ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/12/2025 23:12' prior: 33849886!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].						"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	 ^result	! !----QUIT/NOSAVE----2025-06-12T23:20:22.93-04:00 Polarity.image priorSource: 292270!!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/12/2025 23:22' prior: 33843919!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.										Transcript show: result; cr.									].				]. 			].				].	]. 	 ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/12/2025 23:23' prior: 33855081!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr.					Transcript show: mspecs; cr.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.										Transcript show: result; cr.					Transcript show: mspecs; cr.									].				]. 			].				].	]. 	 ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/12/2025 23:27' prior: 33857906!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].				].	]. 	 ^result	! !----QUIT/NOSAVE----2025-06-12T23:29:05.638-04:00 Polarity.image priorSource: 292270!----QUIT/NOSAVE----2025-06-14T02:34:53.381-04:00 Polarity.image priorSource: 292270!----QUIT/NOSAVE----2025-06-14T11:54:56.957-04:00 Polarity.image priorSource: 292270!----QUIT/NOSAVE----2025-06-15T05:03:53.518-04:00 Polarity.image priorSource: 292270!!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/25/2025 01:14' prior: 33843919!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr. 				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr. 									].				]. 			].		].	]. 	 ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/25/2025 01:19' prior: 33863894!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr. 				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr. 									].				]. 			].		].	]. Transcript show: specs; cr.	 ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/25/2025 01:20' prior: 33866711!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr. 				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.					Transcript show: result; cr. 									].				]. 			].		].	]. Transcript show: mspecs; cr.	 ^result	! !----QUIT----2025-06-25T01:55:21.849-04:00 Polarity.image priorSource: 292270!----QUIT/NOSAVE----2025-06-25T02:37:50.947-04:00 Polarity.image priorSource: 317872!----QUIT----2025-07-11T20:09:46.054-04:00 Polarity.image priorSource: 317872!----QUIT/NOSAVE----2025-07-27T10:21:41.757-04:00 Polarity.image priorSource: 318037!----QUIT----2025-07-27T10:25:33.241-04:00 Polarity.image priorSource: 318037!