----QUIT----2025-03-10T16:31:53.799818+01:00 Pharo11-SNAPSHOT-64bit-88cf2b2744.image priorSource: 0!----QUIT----2025-03-10T16:31:53.800615+01:00 Pharo11-SNAPSHOT-64bit-88cf2b2744.image priorSource: 0!----QUIT----2025-03-10T16:32:13.295897+01:00 Pharo11-SNAPSHOT-64bit-88cf2b2744.image priorSource: 102!----QUIT----2025-03-10T16:32:13.297584+01:00 Pharo11-SNAPSHOT-64bit-88cf2b2744.image priorSource: 204!----QUIT/NOSAVE----2025-05-18T00:12:49.157-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 308!----QUIT/NOSAVE----2025-05-18T00:12:49.174-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 308!!Crag methodsFor: 'as yet unclassified' stamp: 'new 5/18/2025 03:17'!setRoll: dice.	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"roll := dice.! !!Crag class methodsFor: 'instance creation' stamp: 'new 5/18/2025 03:17' prior: 0!new: dice	"comment stating purpose of class-side method"	"scope: class-variables  &  class-instance-variables"|obj|obj := self new.obj setRoll: dice.^obj ! !!Crag class methodsFor: 'as yet unclassified' stamp: 'new 5/18/2025 03:25'!suprise	"comment stating purpose of class-side method"	"scope: class-variables  &  class-instance-variables"|arr|arr := Array with: ((1 to: 6) atRandom) with: ((1 to: 6) atRandom) with: ((1 to: 6) atRandom).^ self new: arr! !!Crag methodsFor: 'as yet unclassified' stamp: 'new 5/18/2025 03:29'!getRoll	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"	^roll! !!Crag class methodsFor: 'instance creation' stamp: 'new 5/18/2025 03:37' prior: 33555342!new: dice	"comment stating purpose of class-side method"	"scope: class-variables  &  class-instance-variables"|obj sum|obj := self new.obj setRoll: dice.1 to: dice size do: [:a | sum := sum + a ].obj setSum: sum.^obj ! !Object subclass: #Crag	instanceVariableNames: 'roll totalSum' 	classVariableNames: ''	package: 'CCPS506'!!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 03:38'!setSum: sumOfDice	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"	totalSum := sumOfDice.! !!Crag class methodsFor: 'instance creation' stamp: 'new 5/18/2025 03:39' prior: 33556097!new: dice	"comment stating purpose of class-side method"	"scope: class-variables  &  class-instance-variables"|obj sum|sum:= 0.obj := self new.obj setRoll: dice.1 to: dice size do: [:a | sum := sum + a ].obj setSum: sum.^obj ! !!Crag methodsFor: 'as yet unclassified' stamp: 'new 5/18/2025 03:39'!getSum	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"^totalSum.! !!Crag class methodsFor: 'instance creation' stamp: 'new 5/18/2025 04:01' prior: 33556735!new: dice	"comment stating purpose of class-side method"	"scope: class-variables  &  class-instance-variables"|obj sum|sum:= 0.obj := self new.obj setRoll: dice.1 to: dice size do: [:a | sum := sum + (dice at:a)  ].obj setSum: sum.^obj ! !!Crag methodsFor: 'as yet unclassified' stamp: 'new 5/18/2025 04:13'!isCraig	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x y z i bool|bool := false.x := (roll at: 1) = (roll at: 3).y := (roll at: 1) = (roll at: 2).z := (roll at: 2) = (roll at: 3).(x = y) | (x = z) | (y =z) ifTrue: [ totalSum = 13 ifTrue: [ bool := true. ] ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 04:13' prior: 33557580!isCraig	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x y z bool|bool := false.x := (roll at: 1) = (roll at: 3).y := (roll at: 1) = (roll at: 2).z := (roll at: 2) = (roll at: 3).(x = y) | (x = z) | (y =z) ifTrue: [ totalSum = 13 ifTrue: [ bool := true. ] ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 04:13' prior: 33557982!isCraig	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x y z bool|bool := false.x := (roll at: 1) = (roll at: 3).y := (roll at: 1) = (roll at: 2).z := (roll at: 2) = (roll at: 3).(x = y) | (x = z) | (y =z) ifTrue: [ totalSum = 13 ifTrue: [ bool := true. ] ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 04:14'!isCrag	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x y z bool|bool := false.x := (roll at: 1) = (roll at: 3).y := (roll at: 1) = (roll at: 2).z := (roll at: 2) = (roll at: 3).(x = y) | (x = z) | (y =z) ifTrue: [ totalSum = 13 ifTrue: [ bool := true. ] ].^bool.! !Crag removeSelector: #isCraig!!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 04:16'!isThirteen	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|bool|bool:= false.totalSum = 13 ifTrue: [ bool := true ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 04:17'!isThreeOfAKind	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x y z bool|bool := false.x := (roll at: 1) = (roll at: 3).y := (roll at: 1) = (roll at: 2).z := (roll at: 2) = (roll at: 3).(x = y) & (x = z) & (y =z) ifTrue: [ bool := true ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 04:26'!isStraight	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x y z bool|bool := false.x := roll includes: (1, 2 , 3).x ifTrue: [ bool := true ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 04:26' prior: 33559806!isStraight	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x y z bool|bool := false.x := roll includes: (1, 2, 3).x ifTrue: [ bool := true ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 04:26' prior: 33560094!isStraight	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x y z bool|bool := false.x := roll includes: 1, 2, 3.x ifTrue: [ bool := true ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 04:37' prior: 33560381!isStraight	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x straights rollSet bool|bool := false.rollSet := roll asSet.straights := { {1. 2. 3} asSet. {4. 5. 6} asSet. {1. 3. 5} asSet. {2. 4. 6} asSet.}.x := straights anySatisfy: [:s | s = rollSet].x ifTrue: [bool:= true].^bool.! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 18 May 2025 at 5:02:59.973 am'!TestCase subclass: #CragTest	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!!CragTest methodsFor: 'tests - isCrag'!test_isCrag_6	| tmp1 |	tmp1 := Crag new: #( 4 5 6 ).	self assert: tmp1 isCrag equals: false! !!CragTest methodsFor: 'tests - isCrag'!test_isCrag_7	| tmp1 |	tmp1 := Crag new: #( 1 2 3 ).	self assert: tmp1 isCrag equals: false! !!CragTest methodsFor: 'tests - isCrag'!test_isCrag_4	| tmp1 |	tmp1 := Crag new: #( 5 5 3 ).	self assert: tmp1 isCrag equals: true! !!CragTest methodsFor: 'tests - isCrag'!test_isCrag_8	| tmp1 |	tmp1 := Crag new: #( 3 4 6 ).	self assert: tmp1 isCrag equals: false! !!CragTest methodsFor: 'tests - isCrag'!test_isCrag_2	| tmp1 |	tmp1 := Crag new: #( 6 1 6 ).	self assert: tmp1 isCrag equals: true! !!CragTest methodsFor: 'tests - isCrag'!test_isCrag_3	| tmp1 |	tmp1 := Crag new: #( 3 5 5 ).	self assert: tmp1 isCrag equals: true! !!CragTest methodsFor: 'tests - isCrag'!test_isCrag_1	| tmp1 |	tmp1 := Crag new: #( 6 6 1 ).	self assert: tmp1 isCrag equals: true! !!CragTest methodsFor: 'tests - isCrag'!test_isCrag_5	| tmp1 |	tmp1 := Crag new: #( 4 5 4 ).	self assert: tmp1 isCrag equals: true! !!CragTest methodsFor: 'tests - isThirteen'!test_isThirteen_5	| tmp1 |	tmp1 := Crag new: #( 4 5 4 ).	self assert: tmp1 isThirteen equals: false! !!CragTest methodsFor: 'tests - isThirteen'!test_isThirteen_7	| tmp1 |	tmp1 := Crag new: #( 1 2 3 ).	self assert: tmp1 isThirteen equals: false! !!CragTest methodsFor: 'tests - isThirteen'!test_isThirteen_1	| tmp1 |	tmp1 := Crag new: #( 6 6 1 ).	self assert: tmp1 isThirteen equals: false! !!CragTest methodsFor: 'tests - isThirteen'!test_isThirteen_3	| tmp1 |	tmp1 := Crag new: #( 3 5 5 ).	self assert: tmp1 isThirteen equals: false! !!CragTest methodsFor: 'tests - isThirteen'!test_isThirteen_2	| tmp1 |	tmp1 := Crag new: #( 6 1 6 ).	self assert: tmp1 isThirteen equals: false! !!CragTest methodsFor: 'tests - isThirteen'!test_isThirteen_8	| tmp1 |	tmp1 := Crag new: #( 3 4 6 ).	self assert: tmp1 isThirteen equals: true! !!CragTest methodsFor: 'tests - isThirteen'!test_isThirteen_4	| tmp1 |	tmp1 := Crag new: #( 5 5 3 ).	self assert: tmp1 isThirteen equals: false! !!CragTest methodsFor: 'tests - isThirteen'!test_isThirteen_6	| tmp1 |	tmp1 := Crag new: #( 4 5 6 ).	self assert: tmp1 isThirteen equals: false! !!CragTest methodsFor: 'tests - isThreeOfAKind'!test_isThreeOfAKind_5	| tmp1 |	tmp1 := Crag new: #( 4 5 4 ).	self assert: tmp1 isThreeOfAKind equals: false! !!CragTest methodsFor: 'tests - isThreeOfAKind'!test_isThreeOfAKind_3	| tmp1 |	tmp1 := Crag new: #( 5 5 5 ).	self assert: tmp1 isThreeOfAKind equals: true! !!CragTest methodsFor: 'tests - isThreeOfAKind'!test_isThreeOfAKind_6	| tmp1 |	tmp1 := Crag new: #( 1 5 6 ).	self assert: tmp1 isThreeOfAKind equals: false! !!CragTest methodsFor: 'tests - isThreeOfAKind'!test_isThreeOfAKind_7	| tmp1 |	tmp1 := Crag new: #( 3 2 3 ).	self assert: tmp1 isThreeOfAKind equals: false! !!CragTest methodsFor: 'tests - isThreeOfAKind'!test_isThreeOfAKind_1	| tmp1 |	tmp1 := Crag new: #( 1 1 1 ).	self assert: tmp1 isThreeOfAKind equals: true! !!CragTest methodsFor: 'tests - isThreeOfAKind'!test_isThreeOfAKind_2	| tmp1 |	tmp1 := Crag new: #( 3 3 3 ).	self assert: tmp1 isThreeOfAKind equals: true! !!CragTest methodsFor: 'tests - isThreeOfAKind'!test_isThreeOfAKind_8	| tmp1 |	tmp1 := Crag new: #( 3 6 6 ).	self assert: tmp1 isThreeOfAKind equals: false! !!CragTest methodsFor: 'tests - isThreeOfAKind'!test_isThreeOfAKind_4	| tmp1 |	tmp1 := Crag new: #( 5 5 3 ).	self assert: tmp1 isThreeOfAKind equals: false! !!CragTest methodsFor: 'tests - isStraight'!test_isStraight_6	| tmp1 |	tmp1 := Crag new: #( 2 3 4 ).	self assert: tmp1 isStraight equals: false! !!CragTest methodsFor: 'tests - isStraight'!test_isStraight_5	| tmp1 |	tmp1 := Crag new: #( 1 4 2 ).	self assert: tmp1 isStraight equals: false! !!CragTest methodsFor: 'tests - isStraight'!test_isStraight_3	| tmp1 |	tmp1 := Crag new: #( 2 4 6 ).	self assert: tmp1 isStraight equals: true! !!CragTest methodsFor: 'tests - isStraight'!test_isStraight_2	| tmp1 |	tmp1 := Crag new: #( 6 5 4 ).	self assert: tmp1 isStraight equals: true! !!CragTest methodsFor: 'tests - isStraight'!test_isStraight_8	| tmp1 |	tmp1 := Crag new: #( 3 3 1 ).	self assert: tmp1 isStraight equals: false! !!CragTest methodsFor: 'tests - isStraight'!test_isStraight_7	| tmp1 |	tmp1 := Crag new: #( 2 5 6 ).	self assert: tmp1 isStraight equals: false! !!CragTest methodsFor: 'tests - isStraight'!test_isStraight_4	| tmp1 |	tmp1 := Crag new: #( 3 5 1 ).	self assert: tmp1 isStraight equals: true! !!CragTest methodsFor: 'tests - isStraight'!test_isStraight_1	| tmp1 |	tmp1 := Crag new: #( 1 3 2 ).	self assert: tmp1 isStraight equals: true! !!CragTest methodsFor: 'tests - score'!test_score_7	| tmp1 |	tmp1 := Crag new: #( 3 1 5 ).	self assert: tmp1 score equals: 20! !!CragTest methodsFor: 'tests - score'!test_score_10	| tmp1 |	tmp1 := Crag new: #( 4 1 1 ).	self assert: tmp1 score equals: 4! !!CragTest methodsFor: 'tests - score'!test_score_5	| tmp1 |	tmp1 := Crag new: #( 4 6 5 ).	self assert: tmp1 score equals: 20! !!CragTest methodsFor: 'tests - score'!test_score_8	| tmp1 |	tmp1 := Crag new: #( 2 1 6 ).	self assert: tmp1 score equals: 6! !!CragTest methodsFor: 'tests - score'!test_score_9	| tmp1 |	tmp1 := Crag new: #( 5 5 6 ).	self assert: tmp1 score equals: 10! !!CragTest methodsFor: 'tests - score'!test_score_2	| tmp1 |	tmp1 := Crag new: #( 3 4 6 ).	self assert: tmp1 score equals: 26! !!CragTest methodsFor: 'tests - score'!test_score_4	| tmp1 |	tmp1 := Crag new: #( 1 3 2 ).	self assert: tmp1 score equals: 20! !!CragTest methodsFor: 'tests - score'!test_score_6	| tmp1 |	tmp1 := Crag new: #( 2 6 4 ).	self assert: tmp1 score equals: 20! !!CragTest methodsFor: 'tests - score'!test_score_1	| tmp1 |	tmp1 := Crag new: #( 5 5 3 ).	self assert: tmp1 score equals: 50! !!CragTest methodsFor: 'tests - score'!test_score_11	| tmp1 |	tmp1 := Crag new: #( 5 3 3 ).	self assert: tmp1 score equals: 6! !!CragTest methodsFor: 'tests - score'!test_score_12	| tmp1 |	tmp1 := Crag new: #( 2 3 2 ).	self assert: tmp1 score equals: 4! !!CragTest methodsFor: 'tests - score'!test_score_3	| tmp1 |	tmp1 := Crag new: #( 1 1 1 ).	self assert: tmp1 score equals: 25! !!CragTest methodsFor: 'tests - category'!test_category_2	| tmp1 |	tmp1 := Crag new: #( 6 3 4 ).	self assert: tmp1 category equals: 'Thirteen'! !!CragTest methodsFor: 'tests - category'!test_category_8	| tmp1 |	tmp1 := Crag new: #( 6 5 6 ).	self assert: tmp1 category equals: 'Sixes'! !!CragTest methodsFor: 'tests - category'!test_category_6	| tmp1 |	tmp1 := Crag new: #( 4 6 2 ).	self assert: tmp1 category equals: 'Even Straight'! !!CragTest methodsFor: 'tests - category'!test_category_12	| tmp1 |	tmp1 := Crag new: #( 3 2 2 ).	self assert: tmp1 category equals: 'Twos'! !!CragTest methodsFor: 'tests - category'!test_category_11	| tmp1 |	tmp1 := Crag new: #( 1 3 1 ).	self assert: tmp1 category equals: 'Threes'! !!CragTest methodsFor: 'tests - category'!test_category_3	| tmp1 |	tmp1 := Crag new: #( 2 2 2 ).	self assert: tmp1 category equals: 'Three-Of-A-Kind'! !!CragTest methodsFor: 'tests - category'!test_category_4	| tmp1 |	tmp1 := Crag new: #( 1 3 2 ).	self assert: tmp1 category equals: 'Low Straight'! !!CragTest methodsFor: 'tests - category'!test_category_7	| tmp1 |	tmp1 := Crag new: #( 5 3 1 ).	self assert: tmp1 category equals: 'Odd Straight'! !!CragTest methodsFor: 'tests - category'!test_category_1	| tmp1 |	tmp1 := Crag new: #( 5 5 3 ).	self assert: tmp1 category equals: 'Crag'! !!CragTest methodsFor: 'tests - category'!test_category_9	| tmp1 |	tmp1 := Crag new: #( 1 5 1 ).	self assert: tmp1 category equals: 'Fives'! !!CragTest methodsFor: 'tests - category'!test_category_5	| tmp1 |	tmp1 := Crag new: #( 6 5 4 ).	self assert: tmp1 category equals: 'High Straight'! !!CragTest methodsFor: 'tests - category'!test_category_10	| tmp1 |	tmp1 := Crag new: #( 4 4 2 ).	self assert: tmp1 category equals: 'Fours'! !!CragTest methodsFor: 'tests - set/get'!test_getRoll	| tmp1 tmp2 |	tmp1 := Crag new: #( 1 2 3 ).	tmp2 := tmp1 getRoll.	self assert: tmp2 equals: #( 1 2 3 )! !!CragTest methodsFor: 'tests - set/get'!test_setRoll	| tmp1 tmp2 |	tmp1 := Crag new: #( 1 2 3 ).	tmp1 setRoll: #( 3 4 5 ).	tmp2 := tmp1 getRoll.	self assert: tmp2 equals: #( 3 4 5 )! !!CragTest methodsFor: 'tests - surprise'!test_surpise_3	| tmp1 tmp2 |	tmp1 := Crag surprise.	tmp2 := tmp1 getRoll.	self assert: tmp2 size equals: 3! !!CragTest methodsFor: 'tests - surprise'!test_surpise_4	| tmp1 tmp2 tmp3 tmp4 tmp5 |	tmp1 := Crag surprise.	tmp2 := tmp1 getRoll.	tmp3 := (tmp2 at: 1) between: 1 and: 6.	tmp4 := (tmp2 at: 2) between: 1 and: 6.	tmp5 := (tmp2 at: 3) between: 1 and: 6.	self assert: tmp3 & tmp4 & tmp5 equals: true! !!CragTest methodsFor: 'tests - surprise'!test_surpise_2	| tmp1 tmp2 |	tmp1 := Crag surprise.	tmp2 := tmp1 getRoll.	self assert: tmp2 class equals: Array! !!CragTest methodsFor: 'tests - surprise'!test_surpise_1	| tmp1 |	tmp1 := Crag surprise.	self assert: tmp1 class equals: Crag! !----End fileIn----!Object subclass: #MyClass	instanceVariableNames: '' 	classVariableNames: ''	package: 'CCPS506'!Smalltalk globals removeClassNamed: #AnObsoleteMyClass!Object subclass: #Crag	instanceVariableNames: 'roll totalSum type'	classVariableNames: ''	package: 'CCPS506'!!Crag methodsFor: 'as yet unclassified' stamp: 'new 5/18/2025 05:48'!subscore	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|result rollSort|result:= 0.rollSort := roll asSortedCollection. (rollSort at: 1) = (rollSort at: 2) ifTrue: [ (rollSort at: 1)*2 <= (rollSort at: 3) ifTrue:[result := rollSort at: 3. type:= rollSort at: 3] ifFalse: [result := (rollSort at: 1)* 2. type := rollSort at: 1]].^result.! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 05:55'!score	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| points |points := 0.roll isCrag ifTrue: [points:= 50] ifFalse: [ 	roll isThirteen ifTrue: [points:= 26] ifFalse:[		roll isThreeOfAKind ifTrue: [points:= 25] ifFalse: [ 			roll isStraight ifTrue: [points:= 20] ifFalse: [ 				points := roll subscore.				]			]		]	].^points.! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 05:58' prior: 33571448!score	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| points |points := 0.(roll isCrag) ifTrue: [points:= 50] ifFalse: [ 	(roll isThirteen) ifTrue: [points:= 26] ifFalse:[		(roll isThreeOfAKind) ifTrue: [points:= 25] ifFalse: [ 			(roll isStraight) ifTrue: [points:= 20] ifFalse: [ 				points := roll subscore.				]			]		]	].^points.! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 06:00' prior: 33571919!score	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| points |points := 0.self isCrag ifTrue: [points:= 50] ifFalse: [ 	self isThirteen ifTrue: [points:= 26] ifFalse:[		self isThreeOfAKind ifTrue: [points:= 25] ifFalse: [ 			self isStraight ifTrue: [points:= 20] ifFalse: [ 				points := roll subscore.				]			]		]	].^points.! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 06:00' prior: 33572398!score	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| points |points := 0.self isCrag ifTrue: [points:= 50] ifFalse: [ 	self isThirteen ifTrue: [points:= 26] ifFalse:[		self isThreeOfAKind ifTrue: [points:= 25] ifFalse: [ 			self isStraight ifTrue: [points:= 20] ifFalse: [ 				points := self subscore.				]			]		]	].^points.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:10' prior: 33559435!isThreeOfAKind	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|bool|bool := false.((roll at: 1) = (roll at: 2) and: [ (roll at: 2) = (roll at: 3) ] )  ifTrue: [ bool := true ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:12' prior: 33559195!isThirteen	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|bool|bool:= false.totalSum = 13 ifTrue: [ bool := true ].self isCrag ifTrue: [ bool:= false ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:12' prior: 33573338!isThreeOfAKind	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|bool|bool := false.((roll at: 1) = (roll at: 2) and: [ (roll at: 2) = (roll at: 3) ] )  ifTrue: [ bool := true ].self isThirteen ifTrue: [ bool:= true ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:13' prior: 33560666!isStraight	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x straights rollSet bool|bool := false.rollSet := roll asSet.straights := { {1. 2. 3} asSet. {4. 5. 6} asSet. {1. 3. 5} asSet. {2. 4. 6} asSet.}.x := straights anySatisfy: [:s | s = rollSet].x ifTrue: [bool:= true].self isThreeOfAKind ifTrue: [ bool:= false ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:13' prior: 33573952!isThreeOfAKind	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|bool|bool := false.((roll at: 1) = (roll at: 2) and: [ (roll at: 2) = (roll at: 3) ] )  ifTrue: [ bool := true ].self isThirteen ifTrue: [ bool:= false ].^bool.! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 06:13' prior: 33570985!subscore	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|result rollSort|result:= 0.rollSort := roll asSortedCollection. (rollSort at: 1) = (rollSort at: 2) ifTrue: [ (rollSort at: 1)*2 <= (rollSort at: 3) ifTrue:[result := rollSort at: 3. type:= rollSort at: 3] ifFalse: [result := (rollSort at: 1)* 2. type := rollSort at: 1]].^result.! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 06:17' prior: 33575144!subscore	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|result rollSort|result:= 0.rollSort := roll asSortedCollection. (rollSort at: 1) = (rollSort at: 2) ifTrue: [ (rollSort at: 1)*2 <= (rollSort at: 3) ifTrue:[result := rollSort at: 3. type:= rollSort at: 3] ifFalse: [result := (rollSort at: 1)* 2. type := rollSort at: 1]] ifFalse: [ result:= rollSort at: 3. type := rollSort at: 3 ].^result.! !!Crag class methodsFor: 'instance creation' stamp: 'new 5/18/2025 06:19'!surprise	"comment stating purpose of class-side method"	"scope: class-variables  &  class-instance-variables"|arr|arr := Array with: ((1 to: 6) atRandom) with: ((1 to: 6) atRandom) with: ((1 to: 6) atRandom).^ self new: arr! !Crag class removeSelector: #suprise!!CragTest methodsFor: 'as yet unclassified' stamp: 'new 5/18/2025 06:22'!catergory	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].! !CragTest removeSelector: #catergory!!Crag methodsFor: 'as yet unclassified' stamp: 'new 5/18/2025 06:22'!catergory	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].self isCrag ifTrue: [ ^'Crag' ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:23' prior: 33577185!catergory	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:27' prior: 33574312!isStraight	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x straights rollSet bool|bool := false.rollSet := roll asSet.straights := { {1. 2. 3} asSet -> 'LowStraight'. 					{4. 5. 6} asSet -> 'HighStraight'. 					{1. 3. 5} asSet -> 'OddStraight'. 					{2. 4. 6} asSet -> 'EvenStraight'.}.x := straights anySatisfy: [:s | s = rollSet].x ifTrue: [bool:= true].self isThreeOfAKind ifTrue: [ bool:= false ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:31' prior: 33578144!isStraight	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| x rollSet bool|bool := false.rollSet := roll asSet.rollSet = ({1. 2. 3} asSet) ifTrue: [bool:= true. type:= 'Low Straight' ].rollSet = ({4. 5. 6} asSet) ifTrue: [bool:= true. type:= 'High Straight' ]. rollSet = ({1. 3. 5} asSet) ifTrue: [bool:= true. type:= 'Odd Straight' ].rollSet = ({2. 4. 6} asSet) ifTrue: [bool:= true. type:= 'Even Straight' ].x ifTrue: [bool:= true].self isThreeOfAKind ifTrue: [ bool:= false ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:31' prior: 33578701!isStraight	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| rollSet bool|bool := false.rollSet := roll asSet.rollSet = ({1. 2. 3} asSet) ifTrue: [bool:= true. type:= 'Low Straight' ].rollSet = ({4. 5. 6} asSet) ifTrue: [bool:= true. type:= 'High Straight' ]. rollSet = ({1. 3. 5} asSet) ifTrue: [bool:= true. type:= 'Odd Straight' ].rollSet = ({2. 4. 6} asSet) ifTrue: [bool:= true. type:= 'Even Straight' ].self isThreeOfAKind ifTrue: [ bool:= false ].^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:33' prior: 33577829!catergory	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ]! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 06:33'!category	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ]! !Crag removeSelector: #catergory!!Crag methodsFor: 'nil' stamp: 'new 5/18/2025 06:35' prior: 33580270!category	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ].type = 6 ifTrue: [ ^'Sixes' ].type = 5 ifTrue: [ ^'Fives' ].type = 4 ifTrue: [ ^'Fours' ].type = 3 ifTrue: [ ^'Threes' ].type = 2 ifTrue: [ ^'Twos' ].type = 1 ifTrue: [ ^'Ones' ].! !!ManifestCCPS506 commentStamp: '<historical>' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestCCPS506 class methodsFor: 'code-critics' stamp: 'new 5/18/2025 06:36'!ruleLongMethodsRuleV1FalsePositive	<ignoreForCoverage>	^ #()! !!ManifestCCPS506 class methodsFor: 'code-critics' stamp: 'new 5/18/2025 06:36' prior: 33581507!ruleLongMethodsRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGClassDefinition #(#Crag)) #'2025-05-18T06:36:15.141-04:00') )! !!ManifestCCPS506 class methodsFor: 'code-critics' stamp: 'new 5/18/2025 06:39'!ruleAssignmentInIfTrueRuleV1FalsePositive	<ignoreForCoverage>	^ #()! !!ManifestCCPS506 class methodsFor: 'code-critics' stamp: 'new 5/18/2025 06:39' prior: 33581884!ruleAssignmentInIfTrueRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGClassDefinition #(#Crag)) #'2025-05-18T06:39:04.973-04:00') )! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 06:50' prior: 33575623!subscore	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|result rollSort|result:= 0.rollSort := roll asSortedCollection. (rollSort at: 1) = (rollSort at: 2) ifTrue: [ (rollSort at: 1)*2 <= (rollSort at: 3) ifTrue:[result := rollSort at: 3. type:= rollSort at: 3] ifFalse: [result := (rollSort at: 1)* 2. type := rollSort at: 1]] ifFalse: [ result:= rollSort at: 3. type := rollSort at: 3 ].Transcript show: type.^result.! !----QUIT----2025-05-18T06:51:09.649-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 308!----QUIT----2025-05-18T06:51:09.663-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 28325!!ManifestCCPS506 class methodsFor: 'code-critics' stamp: 'new 5/18/2025 06:53'!ruleCodeCruftLeftInMethodsRuleV1FalsePositive	<ignoreForCoverage>	^ #()! !!ManifestCCPS506 class methodsFor: 'code-critics' stamp: 'new 5/18/2025 06:53' prior: 33583038!ruleCodeCruftLeftInMethodsRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGClassDefinition #(#Crag)) #'2025-05-18T06:53:42.059-04:00') )! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 06:54' prior: 33582271!subscore	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|result rollSort|result:= 0.rollSort := roll asSortedCollection. (rollSort at: 1) = (rollSort at: 2) ifTrue: [ (rollSort at: 1)*2 <= (rollSort at: 3) ifTrue:[result := rollSort at: 3. type:= rollSort at: 3] ifFalse: [result := (rollSort at: 1)* 2. type := rollSort at: 1]] ifFalse: [ result:= rollSort at: 3. type := rollSort at: 3 ].^result.! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 06:58' prior: 33583433!subscore	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|result rollSort|result:= 0.rollSort := roll asSortedCollection. (rollSort at: 1) = (rollSort at: 2) ifTrue: [ (rollSort at: 1)*2 <= (rollSort at: 3) ifTrue:[result := rollSort at: 3. type:= rollSort at: 3] ifFalse: [result := (rollSort at: 1)* 2. type := rollSort at: 1]] ifFalse: [ result:= rollSort at: 3. type := rollSort at: 3 ].Transcript show: type.^result.! !!Crag methodsFor: 'accessing' stamp: 'new 5/18/2025 06:58' prior: 33583973!subscore	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|result rollSort|result:= 0.rollSort := roll asSortedCollection. (rollSort at: 1) = (rollSort at: 2) ifTrue: [ (rollSort at: 1)*2 <= (rollSort at: 3) ifTrue:[result := rollSort at: 3. type:= rollSort at: 3] ifFalse: [result := (rollSort at: 1)* 2. type := rollSort at: 1]] ifFalse: [ result:= rollSort at: 3. type := rollSort at: 3 ].^result.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:00' prior: 33580649!category	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ].type = 6 ifTrue: [ ^'Fours' ].type = 5 ifTrue: [ ^'Fours' ].type = 4 ifTrue: [ ^'Fours' ].type = 3 ifTrue: [ ^'Threes' ].type = 2 ifTrue: [ ^'Twos' ].type = 1 ifTrue: [ ^'Ones' ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:00' prior: 33585075!category	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ].type = 6 ifTrue: [ ^'Fours' ].type = 5 ifTrue: [ ^'Fours' ].type = 4 ifTrue: [ ^'Fours' ].type = 3 ifTrue: [ ^'Threes' ].(type = 2) ifTrue: [ ^'Twos' ].type = 1 ifTrue: [ ^'Ones' ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:01' prior: 33585609!category	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|x|x:= type asInteger.self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ].x = 6 ifTrue: [ ^'Fours' ].x = 5 ifTrue: [ ^'Fours' ].x = 4 ifTrue: [ ^'Fours' ].x = 3 ifTrue: [ ^'Threes' ].x = 2 ifTrue: [ ^'Twos' ].x = 1 ifTrue: [ ^'Ones' ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:02' prior: 33586145!category	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|x|self score.x:= type.self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ].x = 6 ifTrue: [ ^'Fours' ].x = 5 ifTrue: [ ^'Fours' ].x = 4 ifTrue: [ ^'Fours' ].x = 3 ifTrue: [ ^'Threes' ].x = 2 ifTrue: [ ^'Twos' ].x = 1 ifTrue: [ ^'Ones' ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:05' prior: 33586685!category	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ].self subscore.type = 6 ifTrue: [ ^'Fours' ].type = 5 ifTrue: [ ^'Fours' ].type = 4 ifTrue: [ ^'Fours' ].type = 3 ifTrue: [ ^'Threes' ].type = 2 ifTrue: [ ^'Twos' ].type = 1 ifTrue: [ ^'Ones' ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:06' prior: 33587227!category	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ].self subscore.type = 6 ifTrue: [ ^'Fours' ].type = 5 ifTrue: [ ^'Fives' ].type = 4 ifTrue: [ ^'Fours' ].type = 3 ifTrue: [ ^'Threes' ].type = 2 ifTrue: [ ^'Twos' ].type = 1 ifTrue: [ ^'Ones' ].! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:07' prior: 33587776!category	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"self isCrag ifTrue: [ ^'Crag' ].self isThirteen ifTrue: [ ^'Thirteen' ].self isThreeOfAKind ifTrue: [ ^'Three-Of-A-Kind' ].self isStraight ifTrue: [ ^type ].self subscore.type = 6 ifTrue: [ ^'Sixes' ].type = 5 ifTrue: [ ^'Fives' ].type = 4 ifTrue: [ ^'Fours' ].type = 3 ifTrue: [ ^'Threes' ].type = 2 ifTrue: [ ^'Twos' ].type = 1 ifTrue: [ ^'Ones' ].! !----QUIT----2025-05-18T07:08:22.424-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 28424!----QUIT----2025-05-18T07:08:22.441-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 34367!!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:10' prior: 33579332!isStraight	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| rollSet bool|bool := false.rollSet := roll asSet.rollSet = ({1. 2. 3} asSet) ifTrue: [bool:= true. type:= 'Low Straight' ].rollSet = ({4. 5. 6} asSet) ifTrue: [bool:= true. type:= 'High Straight' ]. rollSet = ({1. 3. 5} asSet) ifTrue: [bool:= true. type:= 'Odd Straight' ].rollSet = ({2. 4. 6} asSet) ifTrue: [bool:= true. type:= 'Even Straight' ]."self isThreeOfAKind ifTrue: [ bool:= false ]."^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:10' prior: 33573657!isThirteen	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|bool|bool:= false.totalSum = 13 ifTrue: [ bool := true ]."self isCrag ifTrue: [ bool:= false ]."^bool.! !!Crag methodsFor: 'testing' stamp: 'new 5/18/2025 07:10' prior: 33574781!isThreeOfAKind	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|bool|bool := false.((roll at: 1) = (roll at: 2) and: [ (roll at: 2) = (roll at: 3) ] )  ifTrue: [ bool := true ]."self isThirteen ifTrue: [ bool:= false ]."^bool.! !----QUIT/NOSAVE----2025-05-18T07:13:31.857-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 34468!----QUIT/NOSAVE----2025-05-18T07:13:31.874-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 34468!----QUIT/NOSAVE----2025-05-22T22:41:33.646-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 34468!----QUIT/NOSAVE----2025-05-22T22:41:33.667-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 34468!----QUIT/NOSAVE----2025-06-05T00:08:18.517-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 34468!----QUIT/NOSAVE----2025-06-05T00:08:18.539-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 34468!'From Pharo10.0.0 of 1 March 2024 [Build information: Pharo-10.0.0+build.539.sha.28169ae414c78e07602b31545f43061b4fa7a88a (64 Bit)] on 15 June 2025 at 5:03:29.905 am'!Object subclass: #Polarity	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Polarity class	instanceVariableNames: ''!!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:44'!validplacement: result row: i column: j type: type|leftb rightb topb bottomb|leftb:= topb := 1.rightb:= (result at: 1) size.bottomb := result size.((result at: i) at: j) == $X ifFalse: [ ^false].(i-1) >= topb ifTrue: [((result at: i-1) at: j)== type ifTrue: [^false]].(i+1) <= bottomb ifTrue: [((result at: i+1)at: j) == type ifTrue: [^false]].(j-1) >= leftb ifTrue: [((result at: i) at:j-1) == type ifTrue: [^false]].(j+1) <= rightb ifTrue: [((result at: i) at:j+1) == type ifTrue: [^false]].^true.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:46'!place: type on: result with: pos at: i and: j    | notType updatedRow updatedOtherRow |    type == $+   ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].    updatedRow := result at: i.    pos == $L ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: (type asString).        updatedRow := updatedRow copyReplaceFrom: (j + 1) to: (j + 1) with: notType asString .        result at: i put: updatedRow.    ].    pos == $R ifTrue: [        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedRow := updatedRow copyReplaceFrom: (j - 1) to: (j - 1) with: notType asString.        result at: i put: updatedRow.    ].    pos == $T ifTrue: [        updatedOtherRow := result at: (i + 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i + 1) put: updatedOtherRow.    ].    pos == $B ifTrue: [        updatedOtherRow := result at: (i - 1).        updatedRow := updatedRow copyReplaceFrom: j to: j with: type asString.        updatedOtherRow := updatedOtherRow copyReplaceFrom: j to: j with: notType asString.        result at: i put: updatedRow.        result at: (i - 1) put: updatedOtherRow.    ].    ^result! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 03:55'!withinbounds: mspecs at: i and: j with: type and: pos|notType|type == $+   ifTrue: [ notType := $- ].type == $- ifTrue: [ notType := $+ ].pos == $L ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i) ~= 0) & ((mspecs at: #top at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i) ~= 0) & ((mspecs at: #bottom at: j+1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $R ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i) ~= 0) & ((mspecs at: #top at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i) ~= 0) & ((mspecs at: #bottom at: j-1) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $T ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i+1) ~= 0) & ((mspecs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i+1) ~= 0) & ((mspecs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].pos == $B ifTrue: [ notType == $+ ifTrue: [((mspecs at: #left at: i-1) ~= 0) & ((mspecs at: #top at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].notType == $- ifTrue: [((mspecs at: #right at: i-1) ~= 0) & ((mspecs at: #bottom at: j) ~= 0) ifTrue: [^true] ifFalse:[^false]].].^false.! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:34'!solve: board with: specs|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	 ^result	! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 05:06'!updateSpecs: mspecs at: i and: j given: pos andType: typetype == $+ ifTrue:[		pos == $L ifTrue: [				mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j+1 put: ((mspecs at: #bottom at: j+1)-1).		^mspecs	].	pos == $R ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j-1 put: ((mspecs at: #bottom at: j-1)-1).		^mspecs	].	pos == $T ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i+1 put: ((mspecs at: #right at: i+1)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $B ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i-1 put: ((mspecs at: #right at: i-1)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].].type == $- ifTrue: [		pos == $L ifTrue: [				mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j+1 put: ((mspecs at: #top at: j+1)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $R ifTrue: [ 		mspecs at: #left at: i put: ((mspecs at: #left at: i)-1).		mspecs at: #top at: j-1 put: ((mspecs at: #top at: j-1)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $T ifTrue: [ 		mspecs at: #left at: i+1 put: ((mspecs at: #left at: i+1)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs  at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].	pos == $B ifTrue: [ 		mspecs at: #left at: i-1 put: ((mspecs at: #left at: i-1)-1).		mspecs at: #top at: j put: ((mspecs at: #top at: j)-1).		mspecs at: #right at: i put: ((mspecs at: #right at: i)-1).		mspecs at: #bottom at: j put: ((mspecs at: #bottom at: j)-1).		^mspecs	].].^mspecs! !!Polarity class methodsFor: 'abstract' stamp: 'SulemanDawood 6/10/2025 04:42'!canPlace: result on: board row:i column: j type: type|pos notType |    type == $+   ifTrue: [ notType := $- ].    type == $- ifTrue: [ notType := $+ ].pos :=((board at: i) at: j).pos == $L ifTrue: [ (self validplacement: result row: i column: j+1 type: (notType)) ifTrue: [^true]].pos == $R ifTrue: [ (self validplacement: result row: i column: j-1 type: (notType))ifTrue: [^true]].			pos == $T ifTrue: [ (self validplacement: result row: i+1 column: j type: (notType))ifTrue: [^true]].pos == $B ifTrue: [ (self validplacement: result row: i-1 column: j type: (notType))ifTrue: [^true]].^false ! !----End fileIn----!'From Pharo11.0.0 of 21 January 2025 [Build information: Pharo-11.0.0+build.735.sha.d63208e5b57d74646d2058654a849c87face150c (64 Bit)] on 29 January 2025 at 4:52:11.703 pm'!Object subclass: #PolarityLog	instanceVariableNames: 'res_1 res_2a res_2b res_3a res_3b res_4a res_4b res_5'	classVariableNames: ''	package: 'CPS506'!!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 16:04'!getAll	| nl |	nl := String with: Character cr.	^ self get_1, nl, self get_2a, nl, self get_2b, nl, self get_3a, nl, self get_3b, nl, 		self get_4a, nl, self get_4b, nl, self get_5! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:38'!get_1	^res_1! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_3b	^res_3b! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_5	^res_5! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_3a	^res_3a! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_3b: result	res_3b := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_4b: result	res_4b := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_5: result	res_5 := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_4a	^res_4a! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_2b: result	res_2b := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_3a: result	res_3a := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:41'!set_1: result	res_1 := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_2a	^res_2a! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_2b	^res_2b! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_4a: result	res_4a := result! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:39'!get_4b	^res_4b! !!PolarityLog methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 12:40'!set_2a: result	res_2a := result! !----End fileIn----!'From Pharo10.0.0 of 1 March 2024 [Build information: Pharo-10.0.0+build.539.sha.28169ae414c78e07602b31545f43061b4fa7a88a (64 Bit)] on 19 February 2025 at 9:05:43.695 am'!TestCase subclass: #PolarityTest	instanceVariableNames: 'log'	classVariableNames: ''	package: 'CPS506'!!PolarityTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 13:43'!validateSol: sol withBoard: board	| rows cols |		rows := board size.	cols := (board at: 1) size.		" Test solution type, should be Array of Bytestrings "	sol class = Array ifFalse: [ ^'Solution should be returned as Array of ByteString' ].	(sol at: 1) class = ByteString ifFalse: [ ^'Solution should be returned as Array of ByteString' ].		" Test solution size, should match board "	sol size = rows ifFalse: [^'Solution and board have different sizes'].	(sol at: 1) size = cols ifFalse: [^'Solution and board have different sizes'].	" Check characters in solution, can only contain +, -, X "	sol do: [ :r | (r reject: [ :c | #( $+ $- $X ) includes: c ]) = '' ifFalse: [ ^'Solution contains illegal characters' ] ].		" Check rows for adjacent same polarity "	sol do: [ :r | 		1 to: cols - 1 do: [ :i | 			| p1 p2 |			p1 := r at: i.			p2 := r at: i+1.			(p1 = p2) & (p1 ~= $X) ifTrue: [ ^'Solution contains equal adjacent poles (++ or --)' ].		]		].	" Check columns for adjacent same polarity "	1 to: rows-1 do: [ :r |		1 to: cols do: [ :c |			| p1 p2 |			p1 := (sol at: r) at: c.			p2 := (sol at: r+1) at: c.			(p1 = p2) & (p1 ~= $X) ifTrue: [ ^'Solution contains equal adjacent poles (++ or --)' ].		]	].		" Check magnet orientation, no monopoles "	1 to: rows do: [ :r |		1 to: cols do: [ :c |			| b1 s1 s2 bar |			b1 := (board at: r) at: c.			s1 := (sol at: r) at: c.						b1 = $L ifTrue: [ s2 := (sol at: r) at: c+1 ].			b1 = $R ifTrue: [ s2 := (sol at: r) at: c-1 ].			b1 = $T ifTrue: [ s2 := (sol at: r+1) at: c ].			b1 = $B ifTrue: [ s2 := (sol at: r-1) at: c ].						bar := String with: s1 with: s2.			(#( 'XX' '+-' '-+' ) includes: bar) 			ifFalse: [ ^'Solution contains illegal tile placement!!!!!!!! Must be one of +-, -+, XX' ]					]	].		^'Board is valid!!'! !!PolarityTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 13:43'!validateSol: sol withSpecs: specs	| left right top bottom rows cols |		rows := sol size.	cols := (sol at: 1) size.		left := specs at: 'left'.	right := specs at: 'right'.	top := specs at: 'top'.	bottom := specs at: 'bottom'.	1 to: rows do: [ :r |		| npos nneg |				npos := (sol at: r) occurrencesOf: $+.		npos = (left at: r) ifFalse: [  			((left at: r) = -1) ifFalse: [ ^'Row ', r asString, ' has wrong number of +' ]		].						nneg := (sol at: r) occurrencesOf: $-.		nneg = (right at: r) ifFalse: [  			((right at: r) = -1) ifFalse: [ ^'Row ', r asString, ' has wrong number of -' ]		].	].	1 to: cols do: [ :c |		| npos nneg |		npos := 0.				nneg := 0.				1 to: rows do: [ :r |			| pole |			pole := (sol at: r) at: c.			pole = $+ ifTrue: [ npos := npos + 1 ].			pole = $- ifTrue: [ nneg := nneg + 1 ].				].			npos = (top at: c) ifFalse: [  			((top at: c) = -1) ifFalse: [ ^'Column ', c asString, ' has wrong number of +' ]		].		nneg = (bottom at: c) ifFalse: [  			((bottom at: c) = -1) ifFalse: [ ^'Column ', c asString, ' has wrong number of -' ]		].	].	^'Constraints met!!'! !!PolarityTest methodsFor: 'initialization' stamp: 'AU 1/29/2025 16:16'!setLog: lg	log := lg! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_5! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:04'!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4b! !----End fileIn----!----QUIT----2025-07-27T15:24:15.162-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 34468!----QUIT----2025-07-27T15:24:15.184-04:00 Pharo 11.0 - 64bit (old stable).image priorSource: 60852!!Polarity class methodsFor: 'abstract' stamp: 'new 7/27/2025 15:30'!solveWith: specs and: board|height width result mspecs |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		"Use this to get dimensions of the board"height:= board size.width:= (board at: 1) size.        mspecs := Dictionary new.        specs keysAndValuesDo: [:key :val |        | newArray |        newArray := Array new: val size.        1 to: val size do: [:i | newArray at: i put: (val at: i) ].        mspecs at: key put: newArray.    ]."Intialize the result"result:= Array new: height.1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ]."Interate over the results board focused on rows polarity first"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm leftVal topVal|		colm:= row at: j.				 leftVal := mspecs at: #left at: i.topVal := mspecs at: #top at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ 				(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [					 mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).					result := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.				].				]. 			].		].	]. "Interate over the results board again, this time for coulumns polarity"1 to: result size do: [:i |	|row |	row:= result at: i.	1 to: row size do: [:j |		|colm|		colm:= row at: j.				"Check if polarity's are still greater than zero if so keep adding pieces"		((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [			( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [				(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ 										mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).					result := self place: $- on: result with: ((board at: i) at: j) at: i and: j.									].				]. 			].		].	]. 	 ^result	! !----SNAPSHOT----2025-07-27T15:32:23.627-04:00 Pharo 11.0 - 64bit (old stable).1.image priorSource: 60953!----SNAPSHOT----2025-07-27T15:32:23.645-04:00 Pharo 11.0 - 64bit (old stable).1.image priorSource: 63779!----SNAPSHOT----2025-07-27T15:35:42.513-04:00 Polarity.image priorSource: 63886!----SNAPSHOT----2025-07-27T15:35:42.53-04:00 Polarity.image priorSource: 63993!----QUIT----2025-07-27T15:47:50.191-04:00 Polarity.image priorSource: 64075!----QUIT----2025-07-27T15:47:50.213-04:00 Polarity.image priorSource: 64156!