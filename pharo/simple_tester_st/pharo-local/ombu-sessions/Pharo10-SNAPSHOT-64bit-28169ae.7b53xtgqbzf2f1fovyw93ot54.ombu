OmEntry {	#tags : {		#author : 'SulemanDawood',		#time : DateAndTime [ '2025-06-12T23:22:09.142-04:00' ],		#prior : OmReference [ 'Pharo10-SNAPSHOT-64bit-28169ae.ue7rbsckw8uzdbnx7zw73gsw', '103' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Polarity class',				#isMetaSide : true			},			#name : #'solve:with:',			#protocol : #abstract,			#sourceCode : 'solve: board with: specs\r\r|height width result mspecs |\r\r\t" \tThe solution to board 1 is hard-coded below, just to demonstrate \r \t  \twhat the return format should look like. It will pass the first\r\t  \ttest like this, but you may NOT leave it like this. Hardcoding is\r\t\tnot allowed.  "\r\t\t\r"Use this to get dimensions of the board"\rheight:= board size.\rwidth:= (board at: 1) size.\r    \r    mspecs := Dictionary new.\r    \r    specs keysAndValuesDo: [:key :val |\r        | newArray |\r        newArray := Array new: val size.\r        1 to: val size do: [:i | newArray at: i put: (val at: i) ].\r        mspecs at: key put: newArray.\r    ].\r\r"Intialize the result"\rresult:= Array new: height.\r1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ].\r\r\r"Interate over the results board focused on rows polarity first"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm leftVal topVal|\r\t\tcolm:= row at: j.\r\t\t\r\t\t \rleftVal := mspecs at: #left at: i.\rtopVal := mspecs at: #top at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ \r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [\r\t\t\t\t\t mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).\r\t\t\t\t\tresult := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.\r\r\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t].\r\t]. \r\r"Interate over the results board again, this time for coulumns polarity"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm|\r\t\tcolm:= row at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [\r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ \t\t\t\t\t\r\t\t\t\t\tmspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).\r\t\t\t\t\tresult := self place: $- on: result with: ((board at: i) at: j) at: i and: j.\r\r\t\t\t\t\r\t\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t].\r\t]. \r\r\r\r\r\r\t\r ^result\r\t',			#stamp : 'SulemanDawood 6/10/2025 05:34',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Polarity class',				#isMetaSide : true			},			#name : #'solve:with:',			#protocol : #abstract,			#sourceCode : 'solve: board with: specs\r\r|height width result mspecs |\r\r\t" \tThe solution to board 1 is hard-coded below, just to demonstrate \r \t  \twhat the return format should look like. It will pass the first\r\t  \ttest like this, but you may NOT leave it like this. Hardcoding is\r\t\tnot allowed.  "\r\t\t\r"Use this to get dimensions of the board"\rheight:= board size.\rwidth:= (board at: 1) size.\r    \r    mspecs := Dictionary new.\r    \r    specs keysAndValuesDo: [:key :val |\r        | newArray |\r        newArray := Array new: val size.\r        1 to: val size do: [:i | newArray at: i put: (val at: i) ].\r        mspecs at: key put: newArray.\r    ].\r\r"Intialize the result"\rresult:= Array new: height.\r1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ].\r\r\r"Interate over the results board focused on rows polarity first"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm leftVal topVal|\r\t\tcolm:= row at: j.\r\t\t\r\t\t \rleftVal := mspecs at: #left at: i.\rtopVal := mspecs at: #top at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ \r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [\r\t\t\t\t\t mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).\r\t\t\t\t\tresult := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.\r\t\t\t\t\tTranscript show: result; cr.\r\r\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t].\r\t]. \r\r"Interate over the results board again, this time for coulumns polarity"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm|\r\t\tcolm:= row at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [\r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ \t\t\t\t\t\r\t\t\t\t\tmspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).\r\t\t\t\t\tresult := self place: $- on: result with: ((board at: i) at: j) at: i and: j.\r\t\t\t\t\t\r\t\t\t\t\tTranscript show: result; cr.\r\r\t\t\t\t\r\t\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t\r\t\t].\r\t]. \r\r\r\r\r\r\t\r ^result\r\t',			#stamp : 'SulemanDawood 6/12/2025 23:22',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'SulemanDawood',		#time : DateAndTime [ '2025-06-12T23:23:33.308-04:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Polarity class',				#isMetaSide : true			},			#name : #'solve:with:',			#protocol : #abstract,			#sourceCode : 'solve: board with: specs\r\r|height width result mspecs |\r\r\t" \tThe solution to board 1 is hard-coded below, just to demonstrate \r \t  \twhat the return format should look like. It will pass the first\r\t  \ttest like this, but you may NOT leave it like this. Hardcoding is\r\t\tnot allowed.  "\r\t\t\r"Use this to get dimensions of the board"\rheight:= board size.\rwidth:= (board at: 1) size.\r    \r    mspecs := Dictionary new.\r    \r    specs keysAndValuesDo: [:key :val |\r        | newArray |\r        newArray := Array new: val size.\r        1 to: val size do: [:i | newArray at: i put: (val at: i) ].\r        mspecs at: key put: newArray.\r    ].\r\r"Intialize the result"\rresult:= Array new: height.\r1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ].\r\r\r"Interate over the results board focused on rows polarity first"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm leftVal topVal|\r\t\tcolm:= row at: j.\r\t\t\r\t\t \rleftVal := mspecs at: #left at: i.\rtopVal := mspecs at: #top at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ \r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [\r\t\t\t\t\t mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).\r\t\t\t\t\tresult := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.\r\t\t\t\t\tTranscript show: result; cr.\r\r\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t].\r\t]. \r\r"Interate over the results board again, this time for coulumns polarity"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm|\r\t\tcolm:= row at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [\r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ \t\t\t\t\t\r\t\t\t\t\tmspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).\r\t\t\t\t\tresult := self place: $- on: result with: ((board at: i) at: j) at: i and: j.\r\t\t\t\t\t\r\t\t\t\t\tTranscript show: result; cr.\r\r\t\t\t\t\r\t\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t\r\t\t].\r\t]. \r\r\r\r\r\r\t\r ^result\r\t',			#stamp : 'SulemanDawood 6/12/2025 23:22',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Polarity class',				#isMetaSide : true			},			#name : #'solve:with:',			#protocol : #abstract,			#sourceCode : 'solve: board with: specs\r\r|height width result mspecs |\r\r\t" \tThe solution to board 1 is hard-coded below, just to demonstrate \r \t  \twhat the return format should look like. It will pass the first\r\t  \ttest like this, but you may NOT leave it like this. Hardcoding is\r\t\tnot allowed.  "\r\t\t\r"Use this to get dimensions of the board"\rheight:= board size.\rwidth:= (board at: 1) size.\r    \r    mspecs := Dictionary new.\r    \r    specs keysAndValuesDo: [:key :val |\r        | newArray |\r        newArray := Array new: val size.\r        1 to: val size do: [:i | newArray at: i put: (val at: i) ].\r        mspecs at: key put: newArray.\r    ].\r\r"Intialize the result"\rresult:= Array new: height.\r1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ].\r\r\r"Interate over the results board focused on rows polarity first"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm leftVal topVal|\r\t\tcolm:= row at: j.\r\t\t\r\t\t \rleftVal := mspecs at: #left at: i.\rtopVal := mspecs at: #top at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ \r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [\r\t\t\t\t\t mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).\r\t\t\t\t\tresult := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.\r\t\t\t\t\tTranscript show: result; cr.\r\t\t\t\t\tTranscript show: mspecs; cr.\r\r\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t].\r\t]. \r\r"Interate over the results board again, this time for coulumns polarity"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm|\r\t\tcolm:= row at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [\r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ \t\t\t\t\t\r\t\t\t\t\tmspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).\r\t\t\t\t\tresult := self place: $- on: result with: ((board at: i) at: j) at: i and: j.\r\t\t\t\t\t\r\t\t\t\t\tTranscript show: result; cr.\r\t\t\t\t\tTranscript show: mspecs; cr.\r\r\t\t\t\t\r\t\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t\r\t\t].\r\t]. \r\r\r\r\r\r\t\r ^result\r\t',			#stamp : 'SulemanDawood 6/12/2025 23:23',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'SulemanDawood',		#time : DateAndTime [ '2025-06-12T23:27:18.979-04:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Polarity class',				#isMetaSide : true			},			#name : #'solve:with:',			#protocol : #abstract,			#sourceCode : 'solve: board with: specs\r\r|height width result mspecs |\r\r\t" \tThe solution to board 1 is hard-coded below, just to demonstrate \r \t  \twhat the return format should look like. It will pass the first\r\t  \ttest like this, but you may NOT leave it like this. Hardcoding is\r\t\tnot allowed.  "\r\t\t\r"Use this to get dimensions of the board"\rheight:= board size.\rwidth:= (board at: 1) size.\r    \r    mspecs := Dictionary new.\r    \r    specs keysAndValuesDo: [:key :val |\r        | newArray |\r        newArray := Array new: val size.\r        1 to: val size do: [:i | newArray at: i put: (val at: i) ].\r        mspecs at: key put: newArray.\r    ].\r\r"Intialize the result"\rresult:= Array new: height.\r1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ].\r\r\r"Interate over the results board focused on rows polarity first"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm leftVal topVal|\r\t\tcolm:= row at: j.\r\t\t\r\t\t \rleftVal := mspecs at: #left at: i.\rtopVal := mspecs at: #top at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ \r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [\r\t\t\t\t\t mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).\r\t\t\t\t\tresult := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.\r\t\t\t\t\tTranscript show: result; cr.\r\t\t\t\t\tTranscript show: mspecs; cr.\r\r\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t].\r\t]. \r\r"Interate over the results board again, this time for coulumns polarity"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm|\r\t\tcolm:= row at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [\r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ \t\t\t\t\t\r\t\t\t\t\tmspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).\r\t\t\t\t\tresult := self place: $- on: result with: ((board at: i) at: j) at: i and: j.\r\t\t\t\t\t\r\t\t\t\t\tTranscript show: result; cr.\r\t\t\t\t\tTranscript show: mspecs; cr.\r\r\t\t\t\t\r\t\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t\r\t\t].\r\t]. \r\r\r\r\r\r\t\r ^result\r\t',			#stamp : 'SulemanDawood 6/12/2025 23:23',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Polarity class',				#isMetaSide : true			},			#name : #'solve:with:',			#protocol : #abstract,			#sourceCode : 'solve: board with: specs\r\r|height width result mspecs |\r\r\t" \tThe solution to board 1 is hard-coded below, just to demonstrate \r \t  \twhat the return format should look like. It will pass the first\r\t  \ttest like this, but you may NOT leave it like this. Hardcoding is\r\t\tnot allowed.  "\r\t\t\r"Use this to get dimensions of the board"\rheight:= board size.\rwidth:= (board at: 1) size.\r    \r    mspecs := Dictionary new.\r    \r    specs keysAndValuesDo: [:key :val |\r        | newArray |\r        newArray := Array new: val size.\r        1 to: val size do: [:i | newArray at: i put: (val at: i) ].\r        mspecs at: key put: newArray.\r    ].\r\r"Intialize the result"\rresult:= Array new: height.\r1 to: height do: [:i | result at: i put: (String new: width withAll: $X) ].\r\r\r"Interate over the results board focused on rows polarity first"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm leftVal topVal|\r\t\tcolm:= row at: j.\r\t\t\r\t\t \rleftVal := mspecs at: #left at: i.\rtopVal := mspecs at: #top at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #left at: i) = 0) not & ((mspecs at: #top at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #left at: i) > 0) | ((mspecs at: #top at: j) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $+) & (self canPlace: result on: board row: i column: j type: $+) ifTrue: [ \r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $+ and: ((board at: i) at: j)) ifTrue: [\r\t\t\t\t\t mspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $+).\r\t\t\t\t\tresult := self place: $+ on: result with: ((board at: i) at: j) at: i and: j.\r\r\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t].\r\t]. \r\r"Interate over the results board again, this time for coulumns polarity"\r1 to: result size do: [:i |\r\t|row |\r\trow:= result at: i.\r\t1 to: row size do: [:j |\r\t\t|colm|\r\t\tcolm:= row at: j.\r\t\t\r\t\t"Check if polarity\'s are still greater than zero if so keep adding pieces"\r\t\t((mspecs at: #right at: i) = 0) not & ((mspecs at: #bottom at: j) = 0) not & (((result at: i) at: j) == $X) & (((mspecs at: #bottom at: j) > 0) | ((mspecs at: #right at: i) > 0)) ifTrue: [\r\t\t\t( self validplacement: result row: i column: j type: $-) & (self canPlace: result on: board row: i column: j type: $-) ifTrue: [\r\t\t\t\t(self withinbounds: mspecs at: i and: j with: $- and: ((board at: i) at: j)) ifTrue: [ \t\t\t\t\t\r\t\t\t\t\tmspecs:= (self updateSpecs: mspecs at: i and: j given: ((board at: i) at: j) andType: $-).\r\t\t\t\t\tresult := self place: $- on: result with: ((board at: i) at: j) at: i and: j.\r\r\t\t\t\t\r\t\t\t\t\t].\r\t\t\t\t]. \r\t\t\t].\r\t\t\r\t\t].\r\t]. \r\r\r\r\r\r\t\r ^result\r\t',			#stamp : 'SulemanDawood 6/12/2025 23:27',			#package : #CPS506		}	}}