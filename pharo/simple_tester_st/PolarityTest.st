'From Pharo10.0.0 of 1 March 2024 [Build information: Pharo-10.0.0+build.539.sha.28169ae414c78e07602b31545f43061b4fa7a88a (64 Bit)] on 19 February 2025 at 9:05:43.695 am'!TestCase subclass: #PolarityTest	instanceVariableNames: 'log'	classVariableNames: ''	package: 'CPS506'!!PolarityTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 13:43'!validateSol: sol withBoard: board	| rows cols |		rows := board size.	cols := (board at: 1) size.		" Test solution type, should be Array of Bytestrings "	sol class = Array ifFalse: [ ^'Solution should be returned as Array of ByteString' ].	(sol at: 1) class = ByteString ifFalse: [ ^'Solution should be returned as Array of ByteString' ].		" Test solution size, should match board "	sol size = rows ifFalse: [^'Solution and board have different sizes'].	(sol at: 1) size = cols ifFalse: [^'Solution and board have different sizes'].	" Check characters in solution, can only contain +, -, X "	sol do: [ :r | (r reject: [ :c | #( $+ $- $X ) includes: c ]) = '' ifFalse: [ ^'Solution contains illegal characters' ] ].		" Check rows for adjacent same polarity "	sol do: [ :r | 		1 to: cols - 1 do: [ :i | 			| p1 p2 |			p1 := r at: i.			p2 := r at: i+1.			(p1 = p2) & (p1 ~= $X) ifTrue: [ ^'Solution contains equal adjacent poles (++ or --)' ].		]		].	" Check columns for adjacent same polarity "	1 to: rows-1 do: [ :r |		1 to: cols do: [ :c |			| p1 p2 |			p1 := (sol at: r) at: c.			p2 := (sol at: r+1) at: c.			(p1 = p2) & (p1 ~= $X) ifTrue: [ ^'Solution contains equal adjacent poles (++ or --)' ].		]	].		" Check magnet orientation, no monopoles "	1 to: rows do: [ :r |		1 to: cols do: [ :c |			| b1 s1 s2 bar |			b1 := (board at: r) at: c.			s1 := (sol at: r) at: c.						b1 = $L ifTrue: [ s2 := (sol at: r) at: c+1 ].			b1 = $R ifTrue: [ s2 := (sol at: r) at: c-1 ].			b1 = $T ifTrue: [ s2 := (sol at: r+1) at: c ].			b1 = $B ifTrue: [ s2 := (sol at: r-1) at: c ].						bar := String with: s1 with: s2.			(#( 'XX' '+-' '-+' ) includes: bar) 			ifFalse: [ ^'Solution contains illegal tile placement!!!!!!!! Must be one of +-, -+, XX' ]					]	].		^'Board is valid!!'! !!PolarityTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2025 13:43'!validateSol: sol withSpecs: specs	| left right top bottom rows cols |		rows := sol size.	cols := (sol at: 1) size.		left := specs at: 'left'.	right := specs at: 'right'.	top := specs at: 'top'.	bottom := specs at: 'bottom'.	1 to: rows do: [ :r |		| npos nneg |				npos := (sol at: r) occurrencesOf: $+.		npos = (left at: r) ifFalse: [  			((left at: r) = -1) ifFalse: [ ^'Row ', r asString, ' has wrong number of +' ]		].						nneg := (sol at: r) occurrencesOf: $-.		nneg = (right at: r) ifFalse: [  			((right at: r) = -1) ifFalse: [ ^'Row ', r asString, ' has wrong number of -' ]		].	].	1 to: cols do: [ :c |		| npos nneg |		npos := 0.				nneg := 0.				1 to: rows do: [ :r |			| pole |			pole := (sol at: r) at: c.			pole = $+ ifTrue: [ npos := npos + 1 ].			pole = $- ifTrue: [ nneg := nneg + 1 ].				].			npos = (top at: c) ifFalse: [  			((top at: c) = -1) ifFalse: [ ^'Column ', c asString, ' has wrong number of +' ]		].		nneg = (bottom at: c) ifFalse: [  			((bottom at: c) = -1) ifFalse: [ ^'Column ', c asString, ' has wrong number of -' ]		].	].	^'Constraints met!!'! !!PolarityTest methodsFor: 'initialization' stamp: 'AU 1/29/2025 16:16'!setLog: lg	log := lg! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_2a_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2a: '2a -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 1) 							 	with: 'right'->#(1 1) 								with: 'top'->#(1 1) 								with: 'bottom'->#(1 1).								board := #( 'TT' 'BB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2a: log get_2a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2a: log get_2a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_2a: log get_2a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_2a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_2b_2x2	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_2b: '2b -  2x2:', nl.	specs := Dictionary 	with: 'left'->#(1 -1) 							 	with: 'right'->#(1 -1) 								with: 'top'->#(1 -1) 								with: 'bottom'->#(-1 1).	board := #( 'LR' 'LR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.		"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_2b: log get_2b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_2b: log get_2b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').	log set_2b: log get_2b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.	^log get_2b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_3b_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3b: '3b -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(1 2 -1 -1) 							 	with:  'right'->#(-1 2 -1 2) 								with:    'top'->#(2 -1 0 2) 								with: 'bottom'->#(2 -1 2 2).	board := #( 'TLRT' 'BLRB' 'TLRT' 'BLRB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3b: log get_3b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3b: log get_3b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3b: log get_3b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3b! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_3a_4x4	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_3a: '3a -  4x4:', nl.	specs := Dictionary 	with:   'left'->#(0 1 2 -1) 							 	with:  'right'->#(0 -1 1 2) 								with:    'top'->#(1 1 -1 1) 								with: 'bottom'->#(1 1 0 2).	board := #( 'TTLR' 'BBLR' 'LRTT' 'LRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_3a: log get_3a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_3a: log get_3a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_3a: log get_3a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_3a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_5_16x16	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_5: '5 -   16x16:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 -1 2 1 4 1 2 0 2 -1 3 2 -1 -1 1) 							 	with:  'right'->#(0 0 3 2 1 2 3 2 0 1 -1 -1 2 1 1 1) 								with:    'top'->#(1 0 0 1 -1 3 2 2 1 -1 3 1 2 -1 2 -1) 								with: 'bottom'->#(1 -1 -1 1 3 1 3 1 0 2 -1 3 2 3 2 0).	board := #( 	'LRLRTTTTTTTTLRLR' 'LRLRBBBBBBBBLRLR' 'LRTTTTLRTTLRLRTT' 'LRBBBBLRBBLRLRBB'  	            	'LRLRLRLRLRLRLRLR' 'TLRTTLRTTLRTTLRT' 'BLRBBLRBBLRBBLRB' 'TTLRLRLRTTLRTTLR' 		         	'BBLRLRLRBBLRBBLR' 'TTLRTLRTLRTTTTLR' 'BBLRBLRBLRBBBBLR' 'LRLRLRLRLRLRLRLR'					'LRLRTTLRLRLRTTTT' 'LRLRBBLRLRLRBBBB' 'TLRTTTTTTLRTTTTT' 'BLRBBBBBBLRBBBBB').	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_5: log get_5, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_5: log get_5, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_5: log get_5, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_5! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:04'!test_1_5x6	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_1: '1 -   5x6:', nl.	specs := Dictionary 	with: 'left'->#(2 3 -1 -1 -1) 							 	with: 'right'->#(-1 -1 -1 1 -1) 								with: 'top'->#(1 -1 -1 2 1 -1) 								with: 'bottom'->#(2 -1 -1 2 -1 3).	board := #( 'LRLRTT' 'LRLRBB' 'TTTTLR' 'BBBBTT' 'LRLRBB' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_1: log get_1, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_1: log get_1, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_1: log get_1, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_1! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_4a_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4a: '4a -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 -1 2 2 4 -1 3 2) 							 	with:  'right'->#(-1 1 -1 3 3 -1 -1 4) 								with:    'top'->#(0 4 3 3 -1 3 -1 1) 								with: 'bottom'->#(2 2 3 3 2 -1 1 3).	board := #( 	'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' 					'LRTTLRTT' 'LRBBLRBB' 'TTLRTTLR' 'BBLRBBLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4a: log get_4a, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4a: log get_4a, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4a: log get_4a, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4a! !!PolarityTest methodsFor: 'tests' stamp: 'AU 2/19/2025 09:05'!test_4b_8x8	| specs board sol passedBoard passedSpecs time nl |		nl := String with: Character cr.	log set_4b: '4b -  8x8:', nl.	specs := Dictionary 	with:   'left'->#(-1 2 2 2 2 2 2 0) 							 	with:  'right'->#(1 1 1 -1 3 3 -1 -1) 								with:    'top'->#(1 0 2 3 2 -1 2 2) 								with: 'bottom'->#(0 2 1 3 2 2 1 -1).	board := #( 	'LRLRLRLR' 'LRLRTLRT' 'TTTTBTTB' 'BBBBTBBT' 	            	'LRLRBTTB' 'TLRTTBBT' 'BLRBBLRB' 'LRLRLRLR' ).	time := Time microsecondClockValue.	sol := Polarity solveWith: specs and: board.	time := Time microsecondClockValue - time // 1000.	"Transcript clear."		passedBoard := self validateSol: sol withBoard: board.	log set_4b: log get_4b, passedBoard, nl.	"Transcript show: passedBoard; cr."	self assert: (passedBoard = 'Board is valid!!').	passedSpecs := self validateSol: sol withSpecs: specs.	log set_4b: log get_4b, passedSpecs, nl.	"Transcript show: passedSpecs; cr."	self assert: (passedSpecs = 'Constraints met!!').		log set_4b: log get_4b, 'Passed in ', time asString, ' ms', nl, sol asString, nl.		^log get_4b! !